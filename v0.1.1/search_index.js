var documenterSearchIndex = {"docs":
[{"location":"submodules/QMath/","page":"QMath","title":"QMath","text":"CurrentModule = QMath","category":"page"},{"location":"submodules/QMath/#QMath","page":"QMath","title":"QMath","text":"","category":"section"},{"location":"submodules/QMath/","page":"QMath","title":"QMath","text":"QMath","category":"page"},{"location":"submodules/QMath/#QBase.QMath","page":"QMath","title":"QBase.QMath","text":"A QBase.jl submodule providing general purpose mathematics useful to quantum mechanics.\n\nExports:\n\nMatrices:\n\npartial_trace - The partial trace matrix operation.\ncomputational_basis_vectors - A general orthonormal set of vectors.\ncommutes - Checks if two matrices commute.\nis_hermitian - Checks if a matrix is hermitian.\nis_positive_semidefinite - Checks if a matrix is positive semi-definite.\nis_square - Checks if a matrix is square.\n\nCombinatorics:\n\nstirling2 - Counts the ways to partition n items into k sets.\nstirling2_partitions - Enumerates the stirling2 partitions.\nstirling2_matrices - Generates matrices representing the stirling2 partitions.\npermutations - Passthrough for Combinatorics.permutations.\npermutation_matrices - Generates the set of permutation matrices.\ncombinations - Passthrough for Combinatorics.combinations.\nn_choose_k_matrices - Generates matrices representing n-choose-k combinations.\nbase_n_val - Converts a base-n number into the base-10 value.\n\nProbability:\n\nis_probability_distribution - Checks if a vector is probability distribution.\nis_conditional_distribution - Checks if a matrix is a conditional probability distribution.\nMarginals - Base type for marginal probability distributions.\nConditionals - Base tyep for conditional probability distributions.\n\n\n\n\n\n","category":"module"},{"location":"submodules/QMath/#Matrices","page":"QMath","title":"Matrices","text":"","category":"section"},{"location":"submodules/QMath/","page":"QMath","title":"QMath","text":"computational_basis_vectors\npartial_trace\ncommutes\nis_hermitian\nis_positive_semidefinite\nis_square","category":"page"},{"location":"submodules/QMath/#QBase.QMath.computational_basis_vectors","page":"QMath","title":"QBase.QMath.computational_basis_vectors","text":"computational_basis_vectors( dim::Int64 ) ::Vector{ Vector{Int64} }\n\nReturns an orthonormal set of column vectors spanning a vector space of dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.partial_trace","page":"QMath","title":"QBase.QMath.partial_trace","text":"partial_trace(\n    ρ::AbstractMatrix, subsystem_dims::Vector{Int64}, subsystem_id::Int64\n) :: AbstractMatrix\n\nPerforms the partial trace on matrix ρ with respect to the subsystem at the specified subsystem_id. The partial trace is a quantum operation mathcalE mapping the input Hilbert space to the output Hilbert space, mathcalE    mathcalH_X rightarrow mathcalH_Y. A quantum operation admits the operator sum representation, mathcalE(rho) = sum_i E_i  rho E_i^dagger. For example, given a 3-qubit system with density matrix rho_ABC, the partial trace with respect to system B, is explicitly,\n\nrho_AC = textTr_Brho_ABC = mathcalE_B(rho_ABC) = sum_i E_i rho_ABC E_i^dagger\n\nwhere E_i = mathbbI_A otimes langle i _B otimesmathbbI_C, represents the Kraus operators for the quantum operation and rho_AC is the reduced density operator remaining after system B is traced out.\n\nInputs:\n\nρ : The matrix on which the partial trace is performed. This matrix should be square       and have dimension equal to the product of the subsystem_dims.\nsubsystem_dims :  A vector containing positive integer elements which specify the       dimension of each subsystem. E.g. A 3-qubit system has subsystem_dims = [2,2,2],       a system containing a qubit and a qutrit has subsystem_dims = [2,3].\nsubsystem_id : A positive integer indexing the subsystem_dims vector to signify       the subsytem which the partial trace will trace out.\n\nOutput:\n\nThe reduced matrix which results after the partial trace is performed on ρ. This       matrix is square and has dimension of product of subsystem_dims with the element       corresponding to subsystem_id removed.\n\nA DomainError is thrown if ρ is not square or of proper dimension.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.commutes","page":"QMath","title":"QBase.QMath.commutes","text":"commutes(A :: Matrix, B :: Matrix) :: Bool\n\nReturns true if matrix A commutes with matrix B. Two matrices commute if A*B == B*A. The matrices must have compatible dimensions:\n\nA: Matrix, mxn dimensions\nB: Matrix, nxm dimensions\n\nA DomainError is thrown if the matrices are not compatible.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.is_hermitian","page":"QMath","title":"QBase.QMath.is_hermitian","text":"is_hermitian( matrix :: Matrix ) :: Bool\n\nReturns true if the supplied matrix is hermitian (self-adjoint).\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.is_positive_semidefinite","page":"QMath","title":"QBase.QMath.is_positive_semidefinite","text":"is_positive_semidefinite(matrix :: Matrix) :: Bool\n\nReturns true if the supplied matrix is positive semidefinite (all eigen values are real and greater than or equal to 0).\n\nA DomainError is thrown if the provided matrix is not square.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.is_square","page":"QMath","title":"QBase.QMath.is_square","text":"is_square( matrix :: Matrix ) :: Bool\n\nReturns true if the provided matrix is square.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#Combinatorics","page":"QMath","title":"Combinatorics","text":"","category":"section"},{"location":"submodules/QMath/","page":"QMath","title":"QMath","text":"stirling2\nstirling2_partitions\nstirling2_matrices\npermutation_matrices\nn_choose_k_matrices\nbase_n_val","category":"page"},{"location":"submodules/QMath/#QBase.QMath.stirling2","page":"QMath","title":"QBase.QMath.stirling2","text":"stirling2( n :: Int64, k :: Int64  ) :: Int64\n\nCounts the number of ways to partition n items into k unlabelled groups. This quantity is known as Stirling's number of the 2nd kind.\n\nThrows a DomainError if inputs do not satisfy n ≥ k ≥ 1.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.stirling2_partitions","page":"QMath","title":"QBase.QMath.stirling2_partitions","text":"stirling2_partitions( n :: Int64, k :: Int64 ) :: Vector{Vector{Vector{Int64}}}\n\nEnumerates the unique partitions of n items into k unlabelled sets. Each partition is a vector containing a  set of k vectors designating each group.\n\nThis recursive algorithm was inspired by this blog.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.stirling2_matrices","page":"QMath","title":"QBase.QMath.stirling2_matrices","text":"stirling2_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Int64}}\n\nGenerates the set of matrices with k rows and n columns where rows correspond to the groups and columns are the grouped elements. A non-zero element designates that the column id is grouped into the corresponding row.\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.permutation_matrices","page":"QMath","title":"QBase.QMath.permutation_matrices","text":"permutation_matrices( dim :: Int64 ) :: Vector{Matrix{Int64}}\n\nGenerates the set of square permutation matrices of dimension dim.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.n_choose_k_matrices","page":"QMath","title":"QBase.QMath.n_choose_k_matrices","text":"n_choose_k_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Int64}}\n\nGenerates a set of n by k matrices which represent all combinations of selecting k columns from n rows.  Each column, contains a single non-zero element and k rows contain a non-zero element.\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.base_n_val","page":"QMath","title":"QBase.QMath.base_n_val","text":"base_n_val(\n    num_array :: Vector{Int64},\n    base :: Int64;\n    big_endian=true :: Bool\n) :: Int64\n\nGiven an array representing a number in base-n returns the value of that number in base-10.\n\nInputs:\n\nnum_array - Vector containing semi-positive integers less than base.\nbase - The base-n number represented by num_array.\nbig_endian - true if most significant place is at index 1, else false.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#Probability","page":"QMath","title":"Probability","text":"","category":"section"},{"location":"submodules/QMath/","page":"QMath","title":"QMath","text":"is_probability_distribution\nis_conditional_distribution\nMarginals\nConditionals","category":"page"},{"location":"submodules/QMath/#QBase.QMath.is_probability_distribution","page":"QMath","title":"QBase.QMath.is_probability_distribution","text":"is_probability_distribution( probabilities :: Vector ) :: Bool\n\nReturns true if the provided vector is a valid probability distribution:\n\nsum(probabilities) ≈ 1\np[i] ≥ 0 ∀ i\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.is_conditional_distribution","page":"QMath","title":"QBase.QMath.is_conditional_distribution","text":"is_conditional_distribution( probabilities :: Matrix ) :: Bool\n\nReturns true if the provided matrix is a valid conditional probability distribution. Each column corresponds to probabilisitic outcomes conditioned for a distinct input.\n\n\n\n\n\n","category":"function"},{"location":"submodules/QMath/#QBase.QMath.Marginals","page":"QMath","title":"QBase.QMath.Marginals","text":"Marginals( probabilities :: Vector ) <: AbstractVector{Float64}\n\nA struct representing a marginal probability distribution function. All elements in the marginal distribution must be positive and their sum must be one.\n\n\n\n\n\n","category":"type"},{"location":"submodules/QMath/#QBase.QMath.Conditionals","page":"QMath","title":"QBase.QMath.Conditionals","text":"Conditionals( probabilities :: Matrix ) <: AbstractMatrix{Float64}\n\nA struct representing a conditional probability distribution function. Conditionals are organized in a matrix with rows correpsonding to outputs and columns corresponding to inputs. For example if there are M inputs and N outputs, the corresponding conditionals matrix takes the form:\n\nbeginbmatrix\np(11)  dots  p(1M) \nvdots  ddots  vdots \np(N1)  dots  p(NM) \nendbmatrix\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/","page":"States","title":"States","text":"CurrentModule = States","category":"page"},{"location":"submodules/States/#States","page":"States","title":"States","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"States","category":"page"},{"location":"submodules/States/#QBase.States","page":"States","title":"QBase.States","text":"The States submodule provides:\n\nabstract and concrete types for quantum state representations.\nA catalog of constructors for instantiating quantum states.\n\n\n\n\n\n","category":"module"},{"location":"submodules/States/","page":"States","title":"States","text":"In discrete and finite quantum systems, states can be represented computationally with vectors (Bra-Ket Representation) or matrices (Density Matrix Representation).","category":"page"},{"location":"submodules/States/#Bra-Ket-Representation","page":"States","title":"Bra-Ket Representation","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"A quantum state is represented by a vector on a complex-valued Hilbert space. In Bra-Ket notation, a quantum state denoted  psirangle is referred to as a ket and is simply understood as a column vector. Each ket has an associated dual vector known as a bra. A bra is may be represented by a row vector and can be constructed from a ket via Hermitian adjoint, langlepsi = (psirangle)^dagger.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"It is essential that a quantum states are normalized, langlepsipsirangle = 1, where langle    rangle denotes the inner product (dot product) between bra and ket.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"The States module provides a validation method, is_ket() for checking whether a vector satisfies the requirements for being a quantum state ket.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"is_ket","category":"page"},{"location":"submodules/States/#QBase.States.is_ket","page":"States","title":"QBase.States.is_ket","text":"is_ket( ψ :: Vector ) :: Bool\n\nReturns true if vector ψ is a valid ket representation of a quamtum state:\n\nψ is a real or complex-valued vector.\nψ is normalized with respect to the bra-ket inner prodcut (ψ' * ψ == 0).\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Ket-Types","page":"States","title":"Ket Types","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"AbstractKet","category":"page"},{"location":"submodules/States/#QBase.States.AbstractKet","page":"States","title":"QBase.States.AbstractKet","text":"AbstractKet <: AbstractVector{Complex{Float64}}\n\nThe abstract type representing a quantum state ket. Since kets are contained within a complex-valued hilbert space, they are appropriately AbstractVector{Complex{Float64}} subtypes. An AbstractKet cannot be instantiated, it serves as a supertype from which ket types are defined.\n\nAn AbstractKet subtype may be operated upon by a AbstractUnitary subtype to produce a new Ket.\n\n*( U :: Unitaries.AbstractUnitary, ψ :: AbstractKet) :: Ket\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/","page":"States","title":"States","text":"The States module provides two concrete subtypes of AbstractKet:","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"Ket\nQubitKet","category":"page"},{"location":"submodules/States/#QBase.States.Ket","page":"States","title":"QBase.States.Ket","text":"Ket( ψ :: Vector{Complex{Float64}} ) <: AbstractKet\n\nA ket representation of a general quantum state. When given invalid input, the constructor, Ket(ψ), throws:\n\nDomainError - If ψ is not normalized.\nMethodError - If ψ is not a column vector ([a,b,c] or [a;b;c])\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/#QBase.States.QubitKet","page":"States","title":"QBase.States.QubitKet","text":"QubitKet( ψ :: Vector{Complex{Float64}} ) <: AbstractKet\n\nA ket representation of a 2-dimensional quantum state. When given invalid input, the constructor, QubitKet(ψ), throws:\n\nDomainError - If ψ is not normalized.\nMethodError - If ψ is not a column vector.\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/#Ket-Constructors","page":"States","title":"Ket Constructors","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"basis_kets\nbell_kets\ngeneralized_bell_kets","category":"page"},{"location":"submodules/States/#QBase.States.basis_kets","page":"States","title":"QBase.States.basis_kets","text":"basis_kets( dim :: Int64 ) :: Vector{Ket}\n\nThe computation basis vectors for a hilbert space of dimension, dim.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.bell_kets","page":"States","title":"QBase.States.bell_kets","text":"bell_kets :: Vector{Ket}\n\nThe Bell basis kets, ordered as Phi^+rangle Phi^-rangle Psi^+rangle Psi^-rangle , where\n\nbeginmatrix\n    Phi^+rangle = frac1sqrt2(00rangle + 11rangle) \n    Phi^-rangle = frac1sqrt2(00rangle - 11rangle) \n    Psi^+rangle = frac1sqrt2(01rangle + 10rangle) \n    Psi^-rangle = frac1sqrt2(01rangle - 10rangle) \nendmatrix\n\n\n\n\n\n","category":"constant"},{"location":"submodules/States/#QBase.States.generalized_bell_kets","page":"States","title":"QBase.States.generalized_bell_kets","text":"generalized_bell_kets( dim :: Int64 ) :: Vector{Ket}\n\nThe Bell basis for quantum states of dimension dim. Each state is constructed by\n\nPsi^p_crangle = frac1sqrtdsum_j=0^d-1 e^i2pi pjdjrangle mod(j+cd)rangle\n\nwhere pcin 0cdots (d-1) and d is dim. When iterated c is the major index and p is the minor index.\n\nA DomainError is thrown if dim ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Singlet-States","page":"States","title":"Singlet States","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"bloch_qubit_ket","category":"page"},{"location":"submodules/States/#QBase.States.bloch_qubit_ket","page":"States","title":"QBase.States.bloch_qubit_ket","text":"bloch_qubit_ket( θ :: Real, ϕ :: Real ) :: QubitKet\n\nReturns the qubit ket for the specified spherical coordinate on the surface of bloch sphere, (r=1, θ, ϕ). If the state does not have a complex phase then\n\nbloch_qubit_ket( θ :: Real ) :: QubitKet\n\ncan be used to construct the state.\n\nInputs:\n\nθ ∈ [0, 2π]: polar angle (w.r.t z-axis)\nϕ ∈ [0, 2π]: azimuthal angle (x-y plane)\n\nA DomainError is thrown if inputs θ and/or ϕ do are not within the valid range.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Triplet-States","page":"States","title":"Triplet States","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"trine_qubit_kets\nmirror_symmetric_qubit_kets\nplanar_symmetric_qubit_kets","category":"page"},{"location":"submodules/States/#QBase.States.trine_qubit_kets","page":"States","title":"QBase.States.trine_qubit_kets","text":"trine_qubit_kets :: Vector{QubitKet}\n\nThe triplet of kets representing three quantum states separated by equal angles in the z-x plane of bloch sphere.\n\njulia> States.trine_qubit_kets == [[1.0, 0], [0.5, sqrt(3)/2], [0.5, -sqrt(3)/2]]\ntrue\n\n\n\n\n\n","category":"constant"},{"location":"submodules/States/#QBase.States.mirror_symmetric_qubit_kets","page":"States","title":"QBase.States.mirror_symmetric_qubit_kets","text":"mirror_symmetric_qubit_kets( θ :: Real ) :: Vector{QubitKet}\n\nReturns the triplet of qubit kets in the z-x plane of bloch sphere. The first ket is  0rangle and the other two are symmetric across the z-axis.\n\nInput:\n\nθ ∈ [0,π/2]: the hilbert space angle between |0> and symmetric kets.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.planar_symmetric_qubit_kets","page":"States","title":"QBase.States.planar_symmetric_qubit_kets","text":"planar_symmetric_qubit_kets( n :: Int64 ) :: Vector{QubitKet}\n\nConstructs a set of QubitKet states oriented symmetrically in the x-z-plane. Each state is separated by a bloch angle of 2π/n. The states are constructed with the form\n\npsi_j rangle = cos(j pin)  0rangle + sin(j pin)1rangle\n\nwhere j in 0cdots (n-1).\n\nA DomainError is thrown if\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Density-Matrix-Representation","page":"States","title":"Density Matrix Representation","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"Quantum states can be represented in matrix form.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"is_density_matrix\nAbstractDensityMatrix\nDensityMatrix\nQubit","category":"page"},{"location":"submodules/States/#QBase.States.is_density_matrix","page":"States","title":"QBase.States.is_density_matrix","text":"is_density_matrix( ρ :: Matrix ) :: Bool\n\nReturns true if input ho is:\n\nHermitian\nPositive Semi-Definite\nTrace[ρ] = 1 (normalization)\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.AbstractDensityMatrix","page":"States","title":"QBase.States.AbstractDensityMatrix","text":"AbstractDensityMatrix <: AbstractMatrix{Complex{Float64}}\n\nThe abstract type representing all density matrices.\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/#QBase.States.DensityMatrix","page":"States","title":"QBase.States.DensityMatrix","text":"DensityMatrix( ρ :: Matrix{Complex{Float64}} ) <: AbstractDensityMatrix\n\nThe density matrix representation of a quantum state. The constructor, DensityMatrix(ρ) throws a DomainError if is_density_matrix(ρ) is false.\n\nBase methods extended to use the DensityMatrix type:\n\nQMath.partial_trace - Returns DensityMatrix if supplied with one.\nBase.kron - The kronecker product of two density matrices is a DensityMatrix.\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/#QBase.States.Qubit","page":"States","title":"QBase.States.Qubit","text":"Qubit( ρ :: Matrix{Complex{Float64}} ) <: AbstractDensityMatrix\n\nThe 2x2 density matrix representation of a qubit. The constructor, Qubit(ρ) throws a DomainError if is_density_matrix(ρ) is false or if ρ is not 2x2 in dimension.\n\n\n\n\n\n","category":"type"},{"location":"submodules/States/#Density-Matrix-Constructors","page":"States","title":"Density Matrix Constructors","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"The density matrix rho can be constructed from ket psirangle by taking the outer-product of the ket with itself, psiranglelanglepsi = rho.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"pure_state\npure_qubit\nbasis_states\nbell_states\ngeneralized_bell_states\nplanar_symmetric_qubits","category":"page"},{"location":"submodules/States/#QBase.States.pure_state","page":"States","title":"QBase.States.pure_state","text":"pure_state( ψ :: AbstractKet ) :: Qubit\n\nA state is considered \"pure\" if it is rank-one. A rank-one density matrix is constructed by  taking the outer-product of a ket state.\n\nThe method alternatively accepts a Vector input.\n\npure_state( ψ :: Vector ) :: Qubit\n\nA DomainError is thrown if ψ is not a valid ket.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.pure_qubit","page":"States","title":"QBase.States.pure_qubit","text":"pure_qubit( ψ :: AbstractKet ) :: Qubit\n\nA qubit is considered \"pure\" if it is rank-one. A rank-one density matrix is constructed by  taking the outer-product of a ket state.\n\nThe method alternatively accepts a Vector input.\n\npure_qubit( ψ :: Vector ) :: Qubit\n\nA DomainError is thrown if ψ is not a valid ket.`\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.basis_states","page":"States","title":"QBase.States.basis_states","text":"basis_states( dim :: Int64 ) :: Vector{DensityMatrix}\n\nThe density matrices for the computational basis of dimension, dim.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.bell_states","page":"States","title":"QBase.States.bell_states","text":"bell_states :: Vector{DensityMatrix}\n\nThe Bell basis density matrices. See States.bell_kets for more details.\n\n\n\n\n\n","category":"constant"},{"location":"submodules/States/#QBase.States.generalized_bell_states","page":"States","title":"QBase.States.generalized_bell_states","text":"generalized_bell_states( dim :: Int64 ) :: Vector{DensityMatrix}\n\nThe density matrix representation of the generalized Bell basis. See  States.bell_kets for more details.\n\nA DomainError is thrown if dim ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.planar_symmetric_qubits","page":"States","title":"QBase.States.planar_symmetric_qubits","text":"planar_symmetric_qubits( n :: Int64 ) :: Vector{Qubit}\n\nConstructs a set of Qubit pure states oriented symmetrically in the x-z-plane. See planar_symmetric_qubit_kets for details.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/","page":"States","title":"States","text":"The rank of the density matrix can be greater than 1. If a density matrix has rank greater than one, we call the state mixed.","category":"page"},{"location":"submodules/States/","page":"States","title":"States","text":"mixed_state\nmixed_qubit\nbloch_qubit","category":"page"},{"location":"submodules/States/#QBase.States.mixed_state","page":"States","title":"QBase.States.mixed_state","text":"mixed_state(\n    priors :: QMath.Marginals,\n    ρ_states :: Vector{<:AbstractDensityMatrix}\n) :: DensityMatrix\n\nConstructs the statistical mixture (weighted average) of quantum states. The method accepts states as type DensityMatrix or subbtypes AbstractDensityMatrix.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.mixed_qubit","page":"States","title":"QBase.States.mixed_qubit","text":"mixed_qubit( priors :: QMath.Marginals, ρ_states :: Vector{Qubit} ) :: Qubit\n\nConstructs the statistical mixture (weighted average) of qubits.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#QBase.States.bloch_qubit","page":"States","title":"QBase.States.bloch_qubit","text":"Returns the qubit density matrix for quantum state described by a coordinate on bloch sphere.\n\nSpherical Coordinates:\n\nStates on the surface of bloch sphere may be described by spherical coordinates.\n\nbloch_qubit(θ::Real, ϕ::Real) :: Qubit\n\nθ ∈ [0, π]: polar angle (w.r.t z-axis).\nϕ ∈ [0, 2π]: azimuthal angle (x-y plane)\n\nCartesian Coordinates:\n\nStates within the volume of bloch sphere may be described in cartesian coordinates.\n\nbloch_qubit(x::Real, y::Real, z::Real) :: Qubit\n\nwhere x, y, and z are constrained to the unit sphere, 0 <= norm([x,y,z]) <= 1.\n\nA DomainError is thrown if the coordinates (x,y,z) do  not adhere to constraints.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Triplets","page":"States","title":"Triplets","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"trine_qubits\nmirror_symmetric_qubits","category":"page"},{"location":"submodules/States/#QBase.States.trine_qubits","page":"States","title":"QBase.States.trine_qubits","text":"trine_qubits :: Vector{Qubit}\n\nReturns the qubit trine states in density matrix form.\n\n\n\n\n\n","category":"constant"},{"location":"submodules/States/#QBase.States.mirror_symmetric_qubits","page":"States","title":"QBase.States.mirror_symmetric_qubits","text":"mirror_symmetric_qubits( θ ::  Real ) :: Vector{Qubit}\n\nReturns a set of 3 mirror symmetric qubit density matrices. The first state is 0ranglelangle 0 the other two are symmetric about the  0rangle axis.\n\nInput:\n\nθ ∈ [0,π/2]: the hilbert space angle between 0rangle and psi_23rangle.\n\n\n\n\n\n","category":"function"},{"location":"submodules/States/#Quadruplets","page":"States","title":"Quadruplets","text":"","category":"section"},{"location":"submodules/States/","page":"States","title":"States","text":"sic_qubits\nbb84_qubits","category":"page"},{"location":"submodules/States/#QBase.States.sic_qubits","page":"States","title":"QBase.States.sic_qubits","text":"sic_qubits :: Vector{Qubit}\n\nThe quadruplet of symmetric informationally complete (SIC) qubits. The qubits are the vertices of a tetrahedron inscribed on bloch sphere.\n\njulia> States.sic_qubits\n4-element Array{QBase.States.Qubit,1}:\n [1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im]\n [0.33333333333333337 + 0.0im 0.47140452079103173 + 0.0im; 0.47140452079103173 + 0.0im 0.6666666666666666 + 0.0im]\n [0.33333333333333337 + 0.0im -0.2357022603955158 - 0.4082482904638631im; -0.2357022603955158 + 0.4082482904638631im 0.6666666666666666 + 0.0im]\n [0.33333333333333337 - 0.0im -0.2357022603955158 + 0.4082482904638631im; -0.2357022603955158 - 0.4082482904638631im 0.6666666666666666 - 0.0im]\n\n\n\n\n\n","category":"constant"},{"location":"submodules/States/#QBase.States.bb84_qubits","page":"States","title":"QBase.States.bb84_qubits","text":"bb84_qubits :: Vector{Qubit}\n\nThe quadruplet of qubits used in the BB84 Quantum Key Distribution protocol. The states are 0ranglelangle 0, 1ranglelangle 1, +ranglelangle +, and - ranglelangle -.\n\njulia> States.bb84_qubits\n4-element Array{QBase.States.Qubit,1}:\n [1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 0.0 + 0.0im]\n [0.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\n [0.5 + 0.0im 0.5 + 0.0im; 0.5 + 0.0im 0.5 + 0.0im]\n [0.5 + 0.0im -0.5 + 0.0im; -0.5 + 0.0im 0.5 + 0.0im]\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Unitaries/","page":"Unitaries","title":"Unitaries","text":"CurrentModule = Unitaries","category":"page"},{"location":"submodules/Unitaries/#Unitaries","page":"Unitaries","title":"Unitaries","text":"","category":"section"},{"location":"submodules/Unitaries/#Types","page":"Unitaries","title":"Types","text":"","category":"section"},{"location":"submodules/Unitaries/","page":"Unitaries","title":"Unitaries","text":"Unitaries\nis_unitary\nAbstractUnitary\nUnitary\nQubitUnitary","category":"page"},{"location":"submodules/Unitaries/#QBase.Unitaries","page":"Unitaries","title":"QBase.Unitaries","text":"Quantum states evolve under unitary transformations. The Unitaries submodule provides:\n\nTypes and Constructors for unitary operators.\n\n\n\n\n\n","category":"module"},{"location":"submodules/Unitaries/#QBase.Unitaries.is_unitary","page":"Unitaries","title":"QBase.Unitaries.is_unitary","text":"is_unitary( U :: Matrix ) :: Bool\n\nReturns true if matrix U is unitary. The hermitian adjoint of a unitary matrix is its inverse:\n\nU' * U == I where I is the identity matrix.\n\nA unitary matrix must be square. A DomainError is thrown if input U is not square.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Unitaries/#QBase.Unitaries.AbstractUnitary","page":"Unitaries","title":"QBase.Unitaries.AbstractUnitary","text":"AbstractUnitary <: AbstractMatrix{Complex{Float64}}\n\nThe abstract type representing unitary operators. An AbstractUnitary cannot be instantiated, it serves as a supertype from which concrete types are derived.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Unitaries/#QBase.Unitaries.Unitary","page":"Unitaries","title":"QBase.Unitaries.Unitary","text":"Unitary( U :: Matrix ) <: AbstractUnitary\n\nUnitary matrices represent the physical evolution of quantum states. The Constructor, Unitary(U), throws a DomainError if the provided matrix, U is not unitary.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Unitaries/#QBase.Unitaries.QubitUnitary","page":"Unitaries","title":"QBase.Unitaries.QubitUnitary","text":"QubitUnitary( U :: Matrix ) <: AbstractUnitary\n\nConstructs a 2x2 unitary for qubit evolution. Throws a DomainError if input U is not of dimension 2x2 or if U is not unitary.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Unitaries/#Constructors","page":"Unitaries","title":"Constructors","text":"","category":"section"},{"location":"submodules/Unitaries/","page":"Unitaries","title":"Unitaries","text":"qubit_rotation\nrandom","category":"page"},{"location":"submodules/Unitaries/#QBase.Unitaries.qubit_rotation","page":"Unitaries","title":"QBase.Unitaries.qubit_rotation","text":"qubit_rotation( θ :: Real; axis=\"x\" :: String ) :: QubitUnitary\n\nReturns a unitary which performs a qubit rotation along bloch sphere. θ designates the angle of rotation and axis (\"x\", \"y\", \"z\") designates the cartesian axis about which the qubit is rotated.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Unitaries/#QBase.Unitaries.random","page":"Unitaries","title":"QBase.Unitaries.random","text":"random( d :: Int64 ) :: Unitary\n\nConstructs a d x d random unitary matrix.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Unitaries/#Constants","page":"Unitaries","title":"Constants","text":"","category":"section"},{"location":"submodules/Unitaries/","page":"Unitaries","title":"Unitaries","text":"paulis\nσx\nσy\nσz","category":"page"},{"location":"submodules/Unitaries/#QBase.Unitaries.paulis","page":"Unitaries","title":"QBase.Unitaries.paulis","text":"paulis :: Vector{QubitUnitary}\n\nReturns a vector containing the three qubit pauli matrices, [σx, σy, σz].\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Unitaries/#QBase.Unitaries.σx","page":"Unitaries","title":"QBase.Unitaries.σx","text":"σx :: QubitUnitary\n\nPauli-X unitary:\n\njulia> Unitaries.σx\n2×2 QBase.Unitaries.QubitUnitary:\n 0.0+0.0im  1.0+0.0im\n 1.0+0.0im  0.0+0.0im\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Unitaries/#QBase.Unitaries.σy","page":"Unitaries","title":"QBase.Unitaries.σy","text":"σy :: QubitUnitary\n\nPauli-Y unitary:\n\njulia> Unitaries.σy\n2×2 QBase.Unitaries.QubitUnitary:\n 0.0+0.0im  0.0-1.0im\n 0.0+1.0im  0.0+0.0im\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Unitaries/#QBase.Unitaries.σz","page":"Unitaries","title":"QBase.Unitaries.σz","text":"σz :: QubitUnitary\n\nPauli-Z unitary:\n\njulia> Unitaries.σz\n2×2 QBase.Unitaries.QubitUnitary:\n 1.0+0.0im   0.0+0.0im\n 0.0+0.0im  -1.0+0.0im\n\n\n\n\n\n","category":"constant"},{"location":"user_guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"user_guide/#Setup","page":"User Guide","title":"Setup","text":"","category":"section"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"Add the QBase.jl Package:","category":"page"},{"location":"user_guide/","page":"User Guide","title":"User Guide","text":"julia> using Pkg; Pkg.add(\"QBase\")","category":"page"},{"location":"submodules/Information/","page":"Information","title":"Information","text":"CurrentModule = QBase.Information","category":"page"},{"location":"submodules/Information/#Information","page":"Information","title":"Information","text":"","category":"section"},{"location":"submodules/Information/","page":"Information","title":"Information","text":"Information","category":"page"},{"location":"submodules/Information/#QBase.Information","page":"Information","title":"QBase.Information","text":"Methods for quantifying information and randomness.\n\nEntropy quantifiers are taken with respect to base-2 logarithms. The entropy is understood as the number of bits {0,1} required to communicate a random result with certainty.\n\n\n\n\n\n","category":"module"},{"location":"submodules/Information/#Entropy","page":"Information","title":"Entropy","text":"","category":"section"},{"location":"submodules/Information/","page":"Information","title":"Information","text":"shannon_entropy\nvon_neumann_entropy\njoint_entropy\nconditional_entropy","category":"page"},{"location":"submodules/Information/#QBase.Information.shannon_entropy","page":"Information","title":"QBase.Information.shannon_entropy","text":"shannon_entropy( probabilities :: QMath.Marginals ) :: Float64\n\nshannon_entropy( probabilities :: Vector{<:Real}) :: Float64\n\nThe classical entropy of a probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.von_neumann_entropy","page":"Information","title":"QBase.Information.von_neumann_entropy","text":"von_neumann_entropy( ρ :: States.AbstractDensityMatrix ) :: Float64\n\nvon_neumann_entropy( ρ :: Matrix{<:Number} ) :: Float64\n\nThe von neumann entropy of a density matrix.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.joint_entropy","page":"Information","title":"QBase.Information.joint_entropy","text":"joint_entropy(priors :: QMath.Marginals, conditionals :: QMath.Conditionals) :: Float64\n\nReturns the entropy for the union of pdf P(xy).\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.conditional_entropy","page":"Information","title":"QBase.Information.conditional_entropy","text":"conditional_entropy(priors::QMath.Marginals, conditionals::QMath.Conditionals) :: Float64\n\nReturns the conditional entropy for the system with specified priors and conditionals.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#Information-2","page":"Information","title":"Information","text":"","category":"section"},{"location":"submodules/Information/","page":"Information","title":"Information","text":"holevo_bound\nholevo_information\nmutual_information","category":"page"},{"location":"submodules/Information/#QBase.Information.holevo_bound","page":"Information","title":"QBase.Information.holevo_bound","text":"holevo_bound(\n    priors :: QMath.Marginals,\n    ρ_states :: Vector{<:AbstractDensityMatrix}\n) :: Float64\n\nholevo_bound(\n    priors :: Vector{<:Real},\n    ρ_states :: Vector{Matrix{<:Number}}\n) :: Float64\n\nComputes the upper bound of a quantum channel's information capacity. The information shared through a quantum channel cannot exceed a classical channel of the same dimension.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.holevo_information","page":"Information","title":"QBase.Information.holevo_information","text":"holevo_information(\n    priors :: QMath.Marginals,\n    ρ_states :: Vector{<:AbstractDensityMatrix},\n    Π :: Observables.AbstractPOVM\n) :: Float64\n\nComputes the holevo (mutual) information shared through a quantum channel.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.mutual_information","page":"Information","title":"QBase.Information.mutual_information","text":"mutual_information(\n    priors :: QMath.Marginals,\n    conditionals :: QMath.Conditionals\n) :: Float64\n\nThe entropy of the overlap between p(x) and p(y). The information shared from y to x.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#State-Discrimination","page":"Information","title":"State Discrimination","text":"","category":"section"},{"location":"submodules/Information/","page":"Information","title":"Information","text":"success_probability\nerror_probability","category":"page"},{"location":"submodules/Information/#QBase.Information.success_probability","page":"Information","title":"QBase.Information.success_probability","text":"success_probability(\n    priors::QMath.Marginals,\n    ρ_states::Vector{<:States.AbstractDensityMatrix},\n    Π::Observables.AbstractPOVM\n) :: Float64\n\nThe probability of correctly distinguishing quantum states with the specifed POVM.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Information/#QBase.Information.error_probability","page":"Information","title":"QBase.Information.error_probability","text":"error_probability(\n    priors::QMath.Marginals,\n    ρ_states::Vector{<:States.AbstractDensityMatrix},\n    Π::Observables.AbstractPOVM\n) :: Float64\n\nThe probability of incorrectly distinguishing quantum states with the specifed POVM.\n\n\n\n\n\n","category":"function"},{"location":"exports/#QBase.jl-Exports","page":"Exports","title":"QBase.jl - Exports","text":"","category":"section"},{"location":"exports/","page":"Exports","title":"Exports","text":"QBase","category":"page"},{"location":"exports/#QBase","page":"Exports","title":"QBase","text":"A collection of methods and submodules useful for computation of quantum sytems.\n\nExports\n\nMethods:\n\nevolve - Performs unitary evolution of quantum states.\nmeasurement_probs - Outcome probabilities of quantum measurement.\n\nModules:\n\nStates - Types and constructors for representing quantum states.\nObservables - Types and constructors for representing measureable quantities.\nUnitaries - Types and constructors for representing unitary operators.\nChannels - A catalog of common quantum channels.\nInformation - Functions for computing information-theoretic quantities.\nQMath - Mathematics useful for modeling quantum operations.\n\n\n\n\n\n","category":"module"},{"location":"exports/#Methods","page":"Exports","title":"Methods","text":"","category":"section"},{"location":"exports/","page":"Exports","title":"Exports","text":"evolve\nmeasurement_probs","category":"page"},{"location":"exports/#QBase.evolve","page":"Exports","title":"QBase.evolve","text":"Apply a unitary evolution U to density matrix ρ.\n\nevolve(\n    U::Unitaries.AbstractUnitary,\n    ρ::States.AbstractDensityMatrix\n) :: DensityMatrix\n\nApply a unitary evolution U to a state ket ψ.\n\nevolve(\n    U::Unitaries.AbstractUnitary,\n    ψ::States.AbstractKet\n) :: Ket\n\n\n\n\n\n","category":"function"},{"location":"exports/#QBase.measurement_probs","page":"Exports","title":"QBase.measurement_probs","text":"Computes the outcome probabilities for a quantum measurement. The conditional probabilities are determined by the Born rule, P(ij) = textTrPi_i rho_j, where Pi_j is a POVM element and rho_j is a density matrix.\n\nMeasurement of a single Ket or  DensityMatrix:\n\nmeasurement_probs(\n    Π :: Observables.AbstractPOVM,\n    ρ :: States.AbstractDensityMatrix\n) :: QMath.Conditionals\n\nmeasurement_probs(\n    Π :: Observables.AbstractPOVM,\n    ψ :: States.AbstractKet\n) :: QMath.Conditionals\n\nMeasurement of an ensemble of Ket or DensityMatrix types:\n\nmeasurement_probs(\n    Π :: Observables.AbstractPOVM,\n    ρ_states :: Vector{<:States.AbstractDensityMatrix}\n) :: QMath.Conditionals\n\nmeasurement_probs(\n    Π :: Observables.AbstractPOVM,\n    ψ_kets :: Vector{<:States.ABstractKet}\n) :: QMath.Conditionals\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QBase","category":"page"},{"location":"#QBase.jl","page":"Home","title":"QBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A base library for quantum information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Alpha Version\nBreaking changes will be made in future commits.","category":"page"},{"location":"#Features:","page":"Home","title":"Features:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Types and constructors for representing quantum states and operators.\nMethods for evolving quantum systems and performing quantum measurements.\nMethods for computing information-theoretic quantities.\nMathematics utilities to support quantum calculations.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please see CITATION.bib for reference of this work.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QBase.jl is released under the MIT License.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of QBase.jl was made possible by the advisory of Dr. Eric Chitambar and general support from the Physics Department at the University of Illinois Urbana-Champaign. Funding was provided by NSF Award 1914440.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"user_guide.md\", \"exports.md\", \"submodules/States.md\", \"submodules/Unitaries.md\", \"submodules/Observables.md\", \"submodules/Channels.md\", \"submodules/Information.md\", \"submodules/QMath.md\"]\nDepth = 1","category":"page"},{"location":"submodules/Channels/","page":"Channels","title":"Channels","text":"CurrentModule = Channels","category":"page"},{"location":"submodules/Channels/#Channels","page":"Channels","title":"Channels","text":"","category":"section"},{"location":"submodules/Channels/","page":"Channels","title":"Channels","text":"Channels\ndepolarizing\nerasure","category":"page"},{"location":"submodules/Channels/#QBase.Channels","page":"Channels","title":"QBase.Channels","text":"The Channels submodule provides:\n\nA catalog of functions which apply common quantum channels to quantum states.\n\n\n\n\n\n","category":"module"},{"location":"submodules/Channels/#QBase.Channels.depolarizing","page":"Channels","title":"QBase.Channels.depolarizing","text":"depolarizing( ρ :: AbstractDensityMatrix, μ :: Real ) :: DensityMatrix\n\nThe depolarizing channel mixes uniform classical noise into a quantum state ρ. The argument μ describes the amount of noise mixed into the quantum states. For a quantum state rho, the depolarizing channel is expressed:\n\n    mathcalD_mu(rho) = mu rho + frac(1 - mu)dmathbbI\n\nA DomainError is thrown if μ does not satisfy 1 ≥ μ ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Channels/#QBase.Channels.erasure","page":"Channels","title":"QBase.Channels.erasure","text":"erasure( ρ :: AbstractDensityMatrix, μ :: Real ) :: DensityMatrix\n\nThe erasure channel mixes a quantum state ρ with an error flag Frangle orthogonal to the Hilbert space of ρ. The argument μ describes the probability that ρ is replaced with the error flag. For a quantum state rho, the erasure channel is expressed:\n\n    mathcalE_mu(rho) = mu rho + (1 - mu) F rangle langle F\n\nNote that the erasure channel increases the dimension of the Hilbert space by 1.\n\nA DomainError is thrown if μ does not satisfy 1 ≥ μ ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/","page":"Observables","title":"Observables","text":"CurrentModule = QBase.Observables","category":"page"},{"location":"submodules/Observables/#Observables","page":"Observables","title":"Observables","text":"","category":"section"},{"location":"submodules/Observables/","page":"Observables","title":"Observables","text":"Observables","category":"page"},{"location":"submodules/Observables/#QBase.Observables","page":"Observables","title":"QBase.Observables","text":"Observables describe measurable quantities of a quantum system. Quantum measurement is a probabilistic process. The measurement outcomes are not definite, but described by conditional probabilities.\n\nThe QBase.Observables submodule provides types and constructors for representing quantum observables.\n\n\n\n\n\n","category":"module"},{"location":"submodules/Observables/#Types","page":"Observables","title":"Types","text":"","category":"section"},{"location":"submodules/Observables/","page":"Observables","title":"Observables","text":"AbstractPOVM\nis_povm\nPOVM\nQubitPOVM","category":"page"},{"location":"submodules/Observables/#QBase.Observables.AbstractPOVM","page":"Observables","title":"QBase.Observables.AbstractPOVM","text":"AbstractPOVM <: AbstractMatrix{Complex{Float64}}\n\nThe abstract type representing positive-operator valued measures (POVMs). An AbstractPOVM cannot be instantiated, it serves as a supertype from which concrete types are derived.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Observables/#QBase.Observables.is_povm","page":"Observables","title":"QBase.Observables.is_povm","text":"is_povm( Π :: Vector ) :: Bool\n\nReturns true if Π is a POVM. The following constraints must be satisfied:\n\nEach POVM element is hermitian\nEach POVM element positive semi-definite\nThe POVM is complete: sum(Π) == I\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#QBase.Observables.POVM","page":"Observables","title":"QBase.Observables.POVM","text":"POVM( Π :: Vector{Matrix} ) <: AbstractPOVM\n\nPositve-operator valued measures (POVMs) represent a general quantum measurement. Each POVM-element is a hermitian, positive-semidefinite matrix. The sum of all POVM-elements yields the identity matrix. The constructor, POVM(Π) throws a DomainError if the provided array of matrices, Π is not a valid POVM.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Observables/#QBase.Observables.QubitPOVM","page":"Observables","title":"QBase.Observables.QubitPOVM","text":"QubitPOVM( Π :: Vector{Matrix} ) <: AbstractPOVM\n\nA general qubit measurement. A DomainError is thrown if Π does not contain 2x2 elements or if it is not a valid POVM.\n\n\n\n\n\n","category":"type"},{"location":"submodules/Observables/#Constructors","page":"Observables","title":"Constructors","text":"","category":"section"},{"location":"submodules/Observables/","page":"Observables","title":"Observables","text":"mirror_symmetric_qubit_3povm\nasymmetric_qubit_3povm\ntrine_qubit_povm\nsic_qubit_povm\nsqrt_povm\nplanar_symmetric_qubit_povm","category":"page"},{"location":"submodules/Observables/#QBase.Observables.mirror_symmetric_qubit_3povm","page":"Observables","title":"QBase.Observables.mirror_symmetric_qubit_3povm","text":"mirror_symmetric_qubit_3povm( θ :: Real ) :: QubitPOVM\n\nConstructs a QubitPOVM aligned with the three mirror symmetric qubit states. The first measurement is aligned with the 0rangle state and the remaining two are symmetric across the z-axis.\n\nA DomainError is thrown if argument θ ∉ [π/4,π/2].\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#QBase.Observables.asymmetric_qubit_3povm","page":"Observables","title":"QBase.Observables.asymmetric_qubit_3povm","text":"asymmetric_qubit_3povm( θ1::Real, θ2::Real ) :: QubitPOVM\n\nConstructs a general non-orthogonal 3-element QubitPOVM.\n\nInputs:\n\nθ1 ∈ (0,π/2] or [-π/2,0), the angle element 2 makes with 0rangle state.\nθ2 ∈ [-π/2,0) or (0,π/2], the angle element 3 makes with 0rangle state.\n\nA DomainError is thrown if θ1 and θ2 are not in the valid ranges. Note that one angle must be positive and the other negative.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#QBase.Observables.trine_qubit_povm","page":"Observables","title":"QBase.Observables.trine_qubit_povm","text":"trine_qubit_povm :: QubitPOVM\n\nThe POVM with elements parallel to the trine qubit states.\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Observables/#QBase.Observables.sic_qubit_povm","page":"Observables","title":"QBase.Observables.sic_qubit_povm","text":"sic_qubit_povm :: QubitPOVM\n\nThe POVM with elements parallel to the symmetric informationally complete (SIC) qubits.\n\n\n\n\n\n","category":"constant"},{"location":"submodules/Observables/#QBase.Observables.sqrt_povm","page":"Observables","title":"QBase.Observables.sqrt_povm","text":"sqrt_povm(priors :: QMath.Marginals, states :: Vector{<:States.AbstractDensityMatrix}) :: POVM\n\nReturns the \"pretty good\" square-root povm for the given density operator states and priors.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#QBase.Observables.planar_symmetric_qubit_povm","page":"Observables","title":"QBase.Observables.planar_symmetric_qubit_povm","text":"planar_symmetric_qubit_povm( n :: Int64 ) :: QubitPOVM\n\nConstructs an n-element QubitPOVM from the planar_symmetric_qubit_states. Each state is multipled by a factor of 2/n to satisfy the completeness relation.\n\nA DomainError is thrown if n ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#Quantum-Measurement","page":"Observables","title":"Quantum Measurement","text":"","category":"section"},{"location":"submodules/Observables/","page":"Observables","title":"Observables","text":"kraus_operators\nnaimark_dilation","category":"page"},{"location":"submodules/Observables/#QBase.Observables.kraus_operators","page":"Observables","title":"QBase.Observables.kraus_operators","text":"kraus_operators(Π::AbstractPOVM) :: Array{Array{Complex{Float64},2},1}\n\nReturns the Kraus operators for the provided POVM. In general, the Kraus operators form a continuum and are non-unique. In this method, the construction\n\nk_i = sqrtPi_i)otimes irangle\n\n\n\n\n\n","category":"function"},{"location":"submodules/Observables/#QBase.Observables.naimark_dilation","page":"Observables","title":"QBase.Observables.naimark_dilation","text":"naimark_dilation( Π::AbstractPOVM )\n\nReturns the dilated projectors which are equivalent to the provided POVM. During measurement, the measured state must be tensored with the ancilla.\n\n\n\n\n\n","category":"function"}]
}
