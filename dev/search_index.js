var documenterSearchIndex = {"docs":
[{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"CurrentModule = QBase","category":"page"},{"location":"math_utilities/#Math-Utilities","page":"Math Utilities","title":"Math Utilities","text":"","category":"section"},{"location":"math_utilities/#Matrices","page":"Math Utilities","title":"Matrices","text":"","category":"section"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"partial_trace\nn_product_id\ncomputational_basis_vectors","category":"page"},{"location":"math_utilities/#QBase.partial_trace","page":"Math Utilities","title":"QBase.partial_trace","text":"partial_trace(\n    ρ :: AbstractMatrix, dims :: Vector{Int64}, id :: Int64\n) :: Matrix\n\nPerforms the partial trace on matrix ρ with respect to the subsystem at the specified id and returns resulting reduced matrix. The returned matrix is square with dimension equal to the product of dims with the element corresponding to id removed.\n\nInputs:\n\nρ : The matrix on which the partial trace is performed. This matrix should be square       and have dimension equal to the product of the dims.\ndims :  A vector containing positive integer elements which specify the       dimension of each subsystem. E.g. A 3-qubit system has dims = [2,2,2],       a system containing a qubit and a qutrit has dims = [2,3].\nid : A positive integer indexing the dims vector to signify       the subsystem to be traced out.\n\nThe partial trace can be understood as a quantum operation mathcalE mapping the input Hilbert space to the output Hilbert space, mathcalE    mathcalH_X rightarrow mathcalH_Y. A quantum operation admits the operator sum representation, mathcalE(rho) = sum_i E_i  rho E_i^dagger. For example, given a 3-qubit system with density matrix rho_ABC, the partial trace with respect to system B, is explicitly,\n\nrho_AC = textTr_Brho_ABC = mathcalE_B(rho_ABC) = sum_i E_i rho_ABC E_i^dagger\n\nwhere E_i = mathbbI_A otimes langle i _B otimesmathbbI_C, represents the Kraus operators for the quantum operation and rho_AC is the reduced density operator remaining after system B is traced out.\n\nA DomainError is thrown if ρ is not square or of proper dimension.\n\n\n\n\n\npartial_trace(ρ::State, system::Vector{Int64}, id::Int64) :: State\n\nTakes the partialtrace of a State ρ to construct a new State: ``\\text{Tr}B[\\rho{AB}] = \\rhoA``.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.n_product_id","page":"Math Utilities","title":"QBase.n_product_id","text":"n_product_id( tensor_coord :: Vector{Int64}, dims :: Vector{Int64} ) :: Int64\n\nFor a given tensor product of subspace dimension dims and tensor coordingate tensor_coord returns the corresponding matrix index of the kronecker product. The tenosr product dims is a vector of positive definite integers specifying the dimension of each of the matrices in the tensor product. The tensor_coord is a vector of positive definite integers specifying the target index in each matrix in the tensor product. The dims and tensor_coord should describe either row or column indices of the tensor product.\n\nA DomainError is thrown if any index in tensor_coord is not valid or the number of elements in tensor_coord does not equal that of dims.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.computational_basis_vectors","page":"Math Utilities","title":"QBase.computational_basis_vectors","text":"computational_basis_vectors( dim::Int64 ) ::Vector{ Vector{Int64} }\n\nReturns the set of orthonormal column vectors 1rangledotsirangledotsdrangle  spanning a vector space of dimension dim. Note that 1rangle = ( 1 0 dots 0 )^T.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#Validation-Methods","page":"Math Utilities","title":"Validation Methods","text":"","category":"section"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"is_hermitian\nis_positive_semidefinite\nis_orthonormal_basis\nis_complete\ncommutes","category":"page"},{"location":"math_utilities/#QBase.is_hermitian","page":"Math Utilities","title":"QBase.is_hermitian","text":"is_hermitian( M :: AbstractMatrix{<:Number}; atol=ATOL :: Float64 ) :: Bool\n\nReturns true if the supplied matrix is hermitian (self-adjoint), M == M'.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.is_positive_semidefinite","page":"Math Utilities","title":"QBase.is_positive_semidefinite","text":"is_positive_semidefinite(M :: AbstractMatrix) :: Bool\n\nReturns true if the supplied matrix is square and positive semidefinite (all eigen values are real and greater than or equal to 0).\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.is_orthonormal_basis","page":"Math Utilities","title":"QBase.is_orthonormal_basis","text":"is_orthonormal_basis(basis_vecs ::  Vector;  atol=ATOL ::  Float64) :: Bool\n\nReturns true if basis_vecs ``{|\\psij\\rangle}{j=1}^n forms an orthonormal basis:\n\nlangle psi_j psi_j rangle = 1 quad textand quad langle psi_j  psi_k rangle = 0\n\nfor all j and k where jneq k.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.is_complete","page":"Math Utilities","title":"QBase.is_complete","text":"is_complete(Π :: Vector{<:AbstractMatrix}; atol=ATOL :: Float64) :: Bool\n\nReturns true if the provided set of matrices sums to the identity.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.commutes","page":"Math Utilities","title":"QBase.commutes","text":"commutes(A :: Matrix, B :: Matrix; atol=ATOL :: Float64) :: Bool\n\nReturns true if matrix A commutes with matrix B. Two matrices commute if A*B == B*A. The matrices must have compatible dimensions:\n\nA: Matrix, mxn dimensions\nB: Matrix, nxm dimensions\n\nA DomainError is thrown if the matrices are not compatible.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#Combinatorics","page":"Math Utilities","title":"Combinatorics","text":"","category":"section"},{"location":"math_utilities/#Set-Partitions","page":"Math Utilities","title":"Set Partitions","text":"","category":"section"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"stirling2\nstirling2_partitions\nstirling2_matrices","category":"page"},{"location":"math_utilities/#QBase.stirling2","page":"Math Utilities","title":"QBase.stirling2","text":"stirling2( n :: Int64, k :: Int64  ) :: Int64\n\nCounts the number of ways to partition n items into k unlabelled groups. This quantity is known as Stirling's number of the 2nd kind:\n\nleftn atop k right = frac1ksum_i=0^k (-1)^ibinomki(k-i)^n\n\nThrows a DomainError if inputs do not satisfy n ≥ k ≥ 1.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.stirling2_partitions","page":"Math Utilities","title":"QBase.stirling2_partitions","text":"stirling2_partitions( n :: Int64, k :: Int64 ) :: Vector{Vector{Vector{Int64}}}\n\nEnumerates the unique partitions of n items into k unlabelled sets. Each partition is a vector containing a  set of k vectors designating each group.\n\nE.g.\n\njulia> stirling2_partitions( 4, 2 )\n7-element Array{Array{Array{Int64,1},1},1}:\n [[1, 2, 3], [4]]\n [[3], [1, 2, 4]]\n [[1, 2], [3, 4]]\n [[1, 3], [2, 4]]\n [[2], [1, 3, 4]]\n [[2, 3], [1, 4]]\n [[1], [2, 3, 4]]\n\nThis recursive algorithm was inspired by this blog.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#QBase.stirling2_matrices","page":"Math Utilities","title":"QBase.stirling2_matrices","text":"stirling2_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates the set of matrices with k rows and n columns where rows correspond to the groups and columns are the grouped elements. A non-zero element designates that the column id is grouped into the corresponding row.\n\nE.g.\n\njulia> stirling2_matrices( 4, 2 )\n7-element Array{Array{Bool,2},1}:\n [1 1 1 0; 0 0 0 1]\n [0 0 1 0; 1 1 0 1]\n [1 1 0 0; 0 0 1 1]\n [1 0 1 0; 0 1 0 1]\n [0 1 0 0; 1 0 1 1]\n [0 1 1 0; 1 0 0 1]\n [1 0 0 0; 0 1 1 1]\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#Permutations","page":"Math Utilities","title":"Permutations","text":"","category":"section"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"permutation_matrices","category":"page"},{"location":"math_utilities/#QBase.permutation_matrices","page":"Math Utilities","title":"QBase.permutation_matrices","text":"permutation_matrices( dim :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates the set of square permutation matrices of dimension dim.\n\nE.g.\n\njulia> permutation_matrices( 3 )\n6-element Array{Array{Bool,2},1}:\n [1 0 0; 0 1 0; 0 0 1]\n [1 0 0; 0 0 1; 0 1 0]\n [0 1 0; 1 0 0; 0 0 1]\n [0 0 1; 1 0 0; 0 1 0]\n [0 1 0; 0 0 1; 1 0 0]\n [0 0 1; 0 1 0; 1 0 0]\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/#Combinations","page":"Math Utilities","title":"Combinations","text":"","category":"section"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"n_choose_k_matrices","category":"page"},{"location":"math_utilities/#QBase.n_choose_k_matrices","page":"Math Utilities","title":"QBase.n_choose_k_matrices","text":"n_choose_k_matrices( n :: Int64, k :: Int64 ) :: Vector{Matrix{Bool}}\n\nGenerates a set of n by k matrices which represent all combinations of selecting k columns from n rows.  Each column, contains a single non-zero element and k rows contain a non-zero element.\n\nE.g.\n\njulia> n_choose_k_matrices( 4, 2 )\n6-element Array{Array{Bool,2},1}:\n [1 0; 0 1; 0 0; 0 0]\n [1 0; 0 0; 0 1; 0 0]\n [1 0; 0 0; 0 0; 0 1]\n [0 0; 1 0; 0 1; 0 0]\n [0 0; 1 0; 0 0; 0 1]\n [0 0; 0 0; 1 0; 0 1]\n\nA DomainError is thrown if n ≥ k ≥ 1 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"math_utilities/","page":"Math Utilities","title":"Math Utilities","text":"base_n_val","category":"page"},{"location":"math_utilities/#QBase.base_n_val","page":"Math Utilities","title":"QBase.base_n_val","text":"base_n_val(\n    num_array :: Vector{Int64},\n    base :: Int64;\n    big_endian=true :: Bool\n) :: Int64\n\nGiven an array representing a number in base-n returns the value of that number in base-10.\n\nInputs:\n\nnum_array - Vector containing semi-positive integers less than base.\nbase - The base-n number represented by num_array.\nbig_endian - true if most significant place is at index 1, else false.\n\n\n\n\n\n","category":"function"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"CurrentModule = QBase","category":"page"},{"location":"measurements/#Measurements","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"measure\nMeasurement","category":"page"},{"location":"measurements/#QBase.measure","page":"Measurements","title":"QBase.measure","text":"Computes the outcome probabilities for a quantum measurement. The conditional probabilities are determined by the Born rule, P(ij) = textTrPi_i rho_j, where Pi_j is a POVM element and rho_j is a density matrix.\n\nMeasurement of a single Ket or  DensityMatrix:\n\nmeasure(\n    Π :: POVM,\n    ρ :: State\n) :: Conditionals\n\nmeasure(\n    Π :: POVM,\n    ψ :: Ket\n) :: Conditionals\n\nMeasurement of an ensemble of Ket or DensityMatrix types:\n\nmeasure(\n    Π :: POVM,\n    ρ_states :: Vector{<:State}\n) :: Conditionals\n\nmeasure(\n    Π :: POVM,\n    ψ_kets :: Vector{<:Ket}\n) :: Conditionals\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.Measurement","page":"Measurements","title":"QBase.Measurement","text":"Measurement{T} <: AbstractVector{T}\n\nThe abstract type representing a quantum measurement. A measurement consists of a complete set of possible outcomes.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#Positive-Operator-Valued-Measures-(POVM)","page":"Measurements","title":"Positive Operator-Valued Measures (POVM)","text":"","category":"section"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"is_povm\nis_povm_element\nPOVM\nPOVMel","category":"page"},{"location":"measurements/#QBase.is_povm","page":"Measurements","title":"QBase.is_povm","text":"is_povm( Π :: Vector; atol=ATOL :: Float64 ) :: Bool\n\nReturns true if Π satisfies the following constraints\n\nThe POVM is complete: sum(Π) == I\nEach POVM element is hermitian\nEach POVM element positive semi-definite\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.is_povm_element","page":"Measurements","title":"QBase.is_povm_element","text":"is_povm_element(M :: AbstractMatrix; atol=ATOL :: Float64) :: Bool\n\nReturns true if matrix M satisfies the following constraints:\n\nM is Hermitian\nM is positive semi-definite\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.POVM","page":"Measurements","title":"QBase.POVM","text":"POVM( Π :: Vector{Matrix{T}} ) <: Measurement{T}\n\nPositve-operator valued measures (POVMs) represent a general quantum measurement. Each POVM-element is a hermitian, positive-semidefinite matrix. The sum of all POVM-elements yields the identity matrix. The constructor, POVM(Π) throws a DomainError if the provided array of matrices, Π is not a valid POVM.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#QBase.POVMel","page":"Measurements","title":"QBase.POVMel","text":"POVMel( M :: AbstractMatrix{T<:Number}; atol=ATOL :: Float64) <: Operator{T}\n\nA POVM element. A DomainError is thrown if matrix M is not hermitian and positive semi-definite within absolute tolerance atol.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#POVM-Constructors","page":"Measurements","title":"POVM Constructors","text":"","category":"section"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"mirror_symmetric_qubit_3povm\nasymmetric_qubit_3povm\ntrine_qubit_povm\nsic_qubit_povm\nplanar_symmetric_qubit_povm\nsqrt_povm\nnaimark_dilation","category":"page"},{"location":"measurements/#QBase.mirror_symmetric_qubit_3povm","page":"Measurements","title":"QBase.mirror_symmetric_qubit_3povm","text":"mirror_symmetric_qubit_3povm( θ :: Real ) :: POVM{Float64}\n\nConstructs a POVM aligned with the three mirror symmetric qubit states. The first measurement is aligned with the 0rangle state and the remaining two are symmetric across the z-axis.\n\nA DomainError is thrown if argument θ ∉ [π/4,π/2].\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.asymmetric_qubit_3povm","page":"Measurements","title":"QBase.asymmetric_qubit_3povm","text":"asymmetric_qubit_3povm( θ1::Real, θ2::Real ) :: POVM\n\nConstructs a general non-orthogonal 3-element POVM.\n\nInputs:\n\nθ1 ∈ (0,π/2] or [-π/2,0), the angle element 2 makes with 0rangle state.\nθ2 ∈ [-π/2,0) or (0,π/2], the angle element 3 makes with 0rangle state.\n\nA DomainError is thrown if θ1 and θ2 are not in the valid ranges. Note that one angle must be positive and the other negative.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.trine_qubit_povm","page":"Measurements","title":"QBase.trine_qubit_povm","text":"trine_qubit_povm() :: POVM{Float64}\n\nThe POVM with elements parallel to the trine qubit states (see trine_qubit_kets).\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.sic_qubit_povm","page":"Measurements","title":"QBase.sic_qubit_povm","text":"sic_qubit_povm() :: POVM{Complex{Float64}}\n\nThe POVM with elements parallel to the symmetric informationally complete (SIC) qubit states (see sic_qubit_kets).\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.planar_symmetric_qubit_povm","page":"Measurements","title":"QBase.planar_symmetric_qubit_povm","text":"planar_symmetric_qubit_povm( n :: Int64 ) :: POVM{Float64}\n\nConstructs an n-element POVM{Float64} from the planar_symmetric_qubit_states. Each state is multipled by a factor of 2/n to satisfy the completeness relation.\n\nA DomainError is thrown if n ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.sqrt_povm","page":"Measurements","title":"QBase.sqrt_povm","text":"sqrt_povm(priors :: Probabilities, states :: Vector{<:State}) :: POVM\n\nReturns the \"pretty good\" square-root povm for the given density operator states and priors.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#QBase.naimark_dilation","page":"Measurements","title":"QBase.naimark_dilation","text":"naimark_dilation( Π::POVM )\n\nReturns the dilated projectors which are equivalent to the provided POVM. During measurement, the measured state must be tensored with the ancilla.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#Projector-Valued-Measures-(PVM)","page":"Measurements","title":"Projector-Valued Measures (PVM)","text":"","category":"section"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"PVM","category":"page"},{"location":"measurements/#QBase.PVM","page":"Measurements","title":"QBase.PVM","text":"PVM( Π :: Vector{Vector{T}}; atol=ATOL :: Float64 ) <: Measurement{T}\n\nThe concret type for a projector-valued measure. The projectors are represented as a set of orthonormal basis vectors\n\nA DomainError is thrown if Π does not contain an orthonormal basis.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/","page":"Probabilities","title":"Probabilities","text":"CurrentModule = QBase","category":"page"},{"location":"probabilities/#Probabilities","page":"Probabilities","title":"Probabilities","text":"","category":"section"},{"location":"probabilities/","page":"Probabilities","title":"Probabilities","text":"ProbabilityDistribution\nis_probability_distribution\nProbabilities\nConditionalDistribution\nis_conditional_distribution\nConditionals\nJointProbabilityDistribution\nJointProbabilities\noutcome_probabilities","category":"page"},{"location":"probabilities/#QBase.ProbabilityDistribution","page":"Probabilities","title":"QBase.ProbabilityDistribution","text":"abstract type ProbabilityDistribution <: AbstractVector{Real} end\n\nThe abstract type representing a discrete probability distribution.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.is_probability_distribution","page":"Probabilities","title":"QBase.is_probability_distribution","text":"is_probability_distribution(\n    probabilities :: Vector{<:Real};\n    atol=ATOL :: Float64\n) :: Bool\n\nReturns true if the provided vector is a valid probability distribution:\n\nsum(probabilities) ≈ 1\nprobabilities[i] ≥ 0 ∀ i\n\n\n\n\n\n","category":"function"},{"location":"probabilities/#QBase.Probabilities","page":"Probabilities","title":"QBase.Probabilities","text":"Probabilities( distribution :: Vector{<:Real}; atol=ATOL :: Float64 ) <: ProbabilityDistribution\n\nA struct representing a discrete probability distribution. All elements in the marginal distribution must be positive and their sum must be one.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.ConditionalDistribution","page":"Probabilities","title":"QBase.ConditionalDistribution","text":"abstract type ConditionalDistribution <: AbstractMatrix{Real} end\n\nThe abstract type representing a discrete conditional probability distribution.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.is_conditional_distribution","page":"Probabilities","title":"QBase.is_conditional_distribution","text":"is_conditional_distribution( probabilities :: AbstractMatrix{<:Real}; atol=ATOL :: Flaot64 ) :: Bool\n\nReturns true if the provided matrix is column stochastic. That is, each column is a valid probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"probabilities/#QBase.Conditionals","page":"Probabilities","title":"QBase.Conditionals","text":"Conditionals( distribution :: Matrix{<:Real}; atol=ATOL :: Float64 ) <: ConditionalDistribution\n\nA struct representing a conditional probability distribution function. Conditionals are organized in a matrix with rows correpsonding to outputs and columns corresponding to inputs. For example if there are M inputs and N outputs, the corresponding conditionals matrix takes the form:\n\nbeginbmatrix\np(11)  dots  p(1M) \nvdots  ddots  vdots \np(N1)  dots  p(NM) \nendbmatrix\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.JointProbabilityDistribution","page":"Probabilities","title":"QBase.JointProbabilityDistribution","text":"abstract type JointProabilityDistribution <: AbstractMatrix{Real} end\n\nThe abstract type representing a discrete joint probability distribution.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.JointProbabilities","page":"Probabilities","title":"QBase.JointProbabilities","text":"JointProbabilities(\n    distribution :: Matrix{<:Real};\n    atol=ATOL :: Float64\n) <: JointProbabilityDistribution\n\nA struct representing a discrete probability distribution. All elements in the marginal distribution must be positive and their sum must be one. For convenience, the JointProbabilities can also be constructed by passing in a ConditionalDistribution and a ProbabilityDistribution,\n\nJointProbabilities(\n    priors :: AbstractVector{<:Real},\n    conditionals :: AbstractMatrix{<:Real};\n    atol=ATOL :: Float64\n)\n\nOr, two ProbabilityDistributions can be provided\n\nJointProbabilities(\n    priors1 :: AbstractVector{<:Real},\n    priors2 :: AbstractVector{<:Real};\n    atol=ATOL :: Float64\n)\n\nA DomainError is thrown if the joint probability distribution is invalid.\n\n\n\n\n\n","category":"type"},{"location":"probabilities/#QBase.outcome_probabilities","page":"Probabilities","title":"QBase.outcome_probabilities","text":"outcome_probabilities(\n    conditionals::ConditionalDistribution,\n    priors :: ProbabilityDistribution;\n    atol=ATOL :: Float64\n) :: ProbabilityDistribution\n\nReturns the probability of each outcome given priors and conditional probabilities. For convenience, this method can be called with an abstract vector/matrix\n\noutcome_probabilities(\n    conditionals :: AbstractMatrix{<:Real},\n    priors :: AbstractVector{<:Real};\n    atol=ATOL :: Float64\n)\n\nFurthermore, the ordering of the arguments can be reversed. A DomainError is thrown if the constructed vector is not a valid probability distribution.\n\n\n\n\n\n","category":"function"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/#Quickstart","page":"Tutorial","title":"Quickstart","text":"","category":"section"},{"location":"tutorial/#Add-the-QBase.jl-Package:","page":"Tutorial","title":"Add the QBase.jl Package:","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"julia> using Pkg; Pkg.add(\"QBase\")","category":"page"},{"location":"tutorial/#Import-the-QBase-module","page":"Tutorial","title":"Import the QBase module","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using QBase","category":"page"},{"location":"tutorial/#Algebra-with-Bras-and-Kets","page":"Tutorial","title":"Algebra with Bras and Kets","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See the Bras and Kets section for details.","category":"page"},{"location":"tutorial/#Create-a-[Ket](@ref)","page":"Tutorial","title":"Create a Ket","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ψ = Ket([1,0])","category":"page"},{"location":"tutorial/#Create-a-[Bra](@ref)-by-taking-the-adjoint.","page":"Tutorial","title":"Create a Bra by taking the adjoint.","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ψ'","category":"page"},{"location":"tutorial/#Inner-product-between-Bra-and-Ket","page":"Tutorial","title":"Inner product between Bra and Ket","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ψ'ψ","category":"page"},{"location":"tutorial/#Outer-product-between-Ket-and-Bra","page":"Tutorial","title":"Outer product between Ket and Bra","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ψ*ψ'","category":"page"},{"location":"tutorial/#Quantum-States","page":"Tutorial","title":"Quantum States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See States section for details.","category":"page"},{"location":"tutorial/#Constructing-States","page":"Tutorial","title":"Constructing States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ρ_0 = State( [1 0;0 0] )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ρ_1 = State( [0 0;0 1] )","category":"page"},{"location":"tutorial/#Create-Product-States","page":"Tutorial","title":"Create Product States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"kron( ρ_0, ρ_1 )","category":"page"},{"location":"tutorial/#Create-a-Bloch-Qubit-State","page":"Tutorial","title":"Create a Bloch Qubit State","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"bloch_qubit_state( π/3, 7π/6 )","category":"page"},{"location":"tutorial/#Create-a-State-from-a-Ket","page":"Tutorial","title":"Create a State from a Ket","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"pure_state(ψ)","category":"page"},{"location":"tutorial/#Create-a-Mixed-State","page":"Tutorial","title":"Create a Mixed State","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"mixed_state( [0.6, 0.4], [ρ_0, ρ_1] )","category":"page"},{"location":"tutorial/#Evolution-of-Quantum-States","page":"Tutorial","title":"Evolution of Quantum States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See Evolution section for details.","category":"page"},{"location":"tutorial/#Pauli-Constants","page":"Tutorial","title":"Pauli Constants","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"[σI, σx, σy, σz]","category":"page"},{"location":"tutorial/#Unitary-Evolution","page":"Tutorial","title":"Unitary Evolution","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"evolve(σx, ρ_0)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"evolve(σx, ψ)","category":"page"},{"location":"tutorial/#Channel-Evolution","page":"Tutorial","title":"Channel Evolution","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"depolarizing_channel(ρ_0, 0.5)","category":"page"},{"location":"tutorial/#Measurement-of-Quantum-States","page":"Tutorial","title":"Measurement of Quantum States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See Measurements section for details.","category":"page"},{"location":"tutorial/#Constructing-POVM-Measurements","page":"Tutorial","title":"Constructing POVM Measurements","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# measurement in z-basis\nΠ_Z = POVM([ [1 0;0 0], [0 0;0 1] ])","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# measurement in  x-basis\nΠ_X = POVM([ [0.5 0.5;0.5 0.5], [0.5 -0.5;-0.5 0.5] ])","category":"page"},{"location":"tutorial/#Measurement-Probabilities","page":"Tutorial","title":"Measurement Probabilities","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Outcome Probabilities are obtained with the measure method.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"measure( Π_Z, ρ_0 )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"measure( Π_X, ρ_0 )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"measure( Π_Z, [ρ_0, ρ_1] )","category":"page"},{"location":"tutorial/#Quantum-Information","page":"Tutorial","title":"Quantum Information","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"See the Information Theory section for a complete list of methods.","category":"page"},{"location":"tutorial/#Von-Neumann-Entropy-of-Bell-state","page":"Tutorial","title":"Von Neumann Entropy of Bell state","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# maximally entangled bipartite qubit state\nρ_bell = bell_states()[1]\n\nvon_neumann_entropy( ρ_bell )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# maximally mixed two-qubit state\nρ_bell_mix = mixed_state( [1,1,1,1]/4, bell_states() )\n\nvon_neumann_entropy( ρ_bell_mix )","category":"page"},{"location":"tutorial/#Advanced-Examples","page":"Tutorial","title":"Advanced Examples","text":"","category":"section"},{"location":"tutorial/#Absolute-Tolerance","page":"Tutorial","title":"Absolute Tolerance","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In some cases, it may be desirable to relax or tighten the tolerated numerical error. This example demonstrates  how to pass the atol parameter to the State constructor. This parameter can be used for any type defined in this project. The absolute tolerance should be used with caution as it may delegitimize computed results.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"ϵ = 1e-5    # introducing a small error\n\n# state creation fails due to non-hermiticity\ntry\n    State([1 ϵ;-ϵ 0])\ncatch err\n    println( err )\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# the atol parameter overrides the non-hermiticity failure\nState([1 ϵ;-ϵ 0], atol=1e-4)","category":"page"},{"location":"tutorial/#Random-States","page":"Tutorial","title":"Random States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# Create a 5x5 random unitary\nU_rand = random_unitary( 5 )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# evolve the |0> Ket\nψ_rand = U_rand * Ket( [1, 0, 0, 0, 0] )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# create a pure state from the random ket\nρ_rand = pure_state(ψ_rand)","category":"page"},{"location":"tutorial/#Noisy-Quantum-Channel","page":"Tutorial","title":"Noisy Quantum Channel","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing measurement probabilities in a noiseless channel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# create bipartite Bell states\nρ_bell_states = bell_states()\n\n# create a measurement in the same Bell basis\nΠ_bell_basis = POVM( ρ_bell_states )\n\n# compute the ideal measurement probabilities\nmeasure( Π_bell_basis, ρ_bell_states )","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Computing measurement probabilities with a noisy channel:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# create a depolarizing channel which mixes in 50% white noise\n𝒩(ρ) = depolarizing_channel(ρ, 0.5)\n\n# Add noise to quantum states\nρ_noisy_bell_states = 𝒩.(ρ_bell_states)\n\n# compute the noisy measurement probabilities\nmeasure( Π_bell_basis, ρ_noisy_bell_states  )","category":"page"},{"location":"tutorial/#Reduced-Density-States","page":"Tutorial","title":"Reduced Density States","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The reduced density matrix of a Bell state is a maximally mixed state.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# bipartite entangled qutrit states\nρ = generalized_bell_states( 3 )[1]\n\n# tracing out the first qutrit subsystem\n# creates a reduced density matrix State\npartial_trace(ρ, [3,3], 1)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"CurrentModule = QBase","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operator","category":"page"},{"location":"operators/#QBase.Operator","page":"Operators","title":"QBase.Operator","text":"abstract type Operator{T<:Number} <: AbstractMatrix{Number} end\n\nA matrix representing a linear operator that acts upon a complex-valued Hilbert space. The Operator is an abstract type that parents all linear operator in quantum mechanics. These matrix types can represent quantum states, evolution, and measurements, each with their individual constraint. These constraints are place upon the children of th Operator abstract type.\n\n\n\n\n\n","category":"type"},{"location":"operators/#Operator-Algebra","page":"Operators","title":"Operator Algebra","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"*(operators :: Vararg{Operator})\n*(O :: Operator, ket :: Ket)\nkron(operators :: Vararg{Operator})\nrank(O :: Operator)\nsqrt(O :: Operator)","category":"page"},{"location":"operators/#Base.:*-Tuple{Vararg{Operator, N} where N}","page":"Operators","title":"Base.:*","text":"Operator Multiplication:\n\n*(operators :: Vararg{Operator}) :: Matrix\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.:*-Tuple{Operator, Ket}","page":"Operators","title":"Base.:*","text":"Operator types can multiply Bra and Ket types.\n\nOpsirangle =  psi rangle:\n\n*(O :: Operator, ket :: Ket) :: Vector\n\nlangle psi O = langle psi:\n\n*(bra :: Bra, O :: Operator) :: Adjoint{T, Vector{T}} where T <: Number\n\nInner product, langle psi Osigmarangle = langle psisigmarangle:\n\n*(bra :: Bra, O :: Operator, ket :: Ket) :: Number\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.kron-Tuple{Vararg{Operator, N} where N}","page":"Operators","title":"Base.kron","text":"Kronecker Product:\n\nkron(operators :: Vararg{Operator}) :: Matrix\n\n\n\n\n\n","category":"method"},{"location":"operators/#LinearAlgebra.rank-Tuple{Operator}","page":"Operators","title":"LinearAlgebra.rank","text":"Matrix Rank:\n\nrank(O :: Operator) :: Int64\n\n\n\n\n\n","category":"method"},{"location":"operators/#Base.sqrt-Tuple{Operator}","page":"Operators","title":"Base.sqrt","text":"Matrix Square Root:\n\nsqrt(O :: Operator) :: Matrix\n\n\n\n\n\n","category":"method"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"CurrentModule = QBase","category":"page"},{"location":"evolution/#Evolution","page":"Evolution","title":"Evolution","text":"","category":"section"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"evolve\n*(U :: Unitary, ket :: Ket)","category":"page"},{"location":"evolution/#QBase.evolve","page":"Evolution","title":"QBase.evolve","text":"Apply a unitary evolution U to density matrix ρ: rho = Urho U^dagger.\n\nevolve(\n    U :: Unitary,\n    ρ :: State\n) :: State\n\n\n\n\n\nApply a unitary evolution U to a state ket ψ: psirangle = Upsirangle.\n\nevolve(\n    U ::  Unitary,\n    ψ :: Ket\n) :: Ket\n\n\n\n\n\n","category":"function"},{"location":"evolution/#Base.:*-Tuple{Unitary, Ket}","page":"Evolution","title":"Base.:*","text":"*( U :: Unitary, ket :: Ket ) :: Ket\n*( bra :: Bra, U :: Unitary ) :: Bra\n*(U1 :: Unitary, ρ :: State, U2 ::  Unitary) :: Matrix\n\n\n\n\n\n","category":"method"},{"location":"evolution/#Unitaries","page":"Evolution","title":"Unitaries","text":"","category":"section"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"Unitary\nis_unitary","category":"page"},{"location":"evolution/#QBase.Unitary","page":"Evolution","title":"QBase.Unitary","text":"Unitary( U :: AbstractMatrix ) <: Operator{T}\n\nUnitary matrices represent the physical evolution of quantum states. The Constructor, Unitary(U), throws a DomainError if the provided matrix, U is not unitary.\n\n\n\n\n\n","category":"type"},{"location":"evolution/#QBase.is_unitary","page":"Evolution","title":"QBase.is_unitary","text":"is_unitary( U :: Matrix; atol=ATOL :: Float64 ) :: Bool\n\nReturns true if matrix U is unitary. The hermitian adjoint of a unitary matrix is its inverse:\n\nU' * U == I where I is the identity matrix.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#Unitary-Operations","page":"Evolution","title":"Unitary Operations","text":"","category":"section"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"*(unitaries :: Vararg{Unitary}; atol=ATOL :: Float64)\nkron(unitaries :: Vararg{Unitary}; atol=ATOL :: Float64)\nadjoint(U :: Unitary)","category":"page"},{"location":"evolution/#Base.:*-Tuple{Vararg{Unitary, N} where N}","page":"Evolution","title":"Base.:*","text":"*(unitaries :: Vararg{Unitary}; atol=ATOL :: Float64) :: Unitary\n\n\n\n\n\n","category":"method"},{"location":"evolution/#Base.kron-Tuple{Vararg{Unitary, N} where N}","page":"Evolution","title":"Base.kron","text":"kron(unitaries :: Vararg{Unitary}; atol=ATOL :: Float64) :: Unitary\n\n\n\n\n\n","category":"method"},{"location":"evolution/#Base.adjoint-Tuple{Unitary}","page":"Evolution","title":"Base.adjoint","text":"adjoint(U :: Unitary) :: Unitary\n\n\n\n\n\n","category":"method"},{"location":"evolution/#Unitary-Constructors","page":"Evolution","title":"Unitary Constructors","text":"","category":"section"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"σI\nσx\nσy\nσz\nqubit_rotation\nrandom_unitary","category":"page"},{"location":"evolution/#QBase.σI","page":"Evolution","title":"QBase.σI","text":"σI :: Unitary{Int64}\n\nIdentity unitary:\n\njulia> σI\n2×2 Unitary{Int64}:\n 1  0\n 0  1\n\n\n\n\n\n","category":"constant"},{"location":"evolution/#QBase.σx","page":"Evolution","title":"QBase.σx","text":"σx :: Unitary{Int64}\n\nPauli-X unitary:\n\njulia> σx\n2×2 Unitary{Int64}:\n 0  1\n 1  0\n\n\n\n\n\n","category":"constant"},{"location":"evolution/#QBase.σy","page":"Evolution","title":"QBase.σy","text":"σy :: Unitary{Complex{Int64}}\n\nPauli-Y unitary:\n\njulia> σy\n2×2 Unitary{Complex{Int64}}:\n 0+0im  0-1im\n 0+1im  0+0im\n\n\n\n\n\n","category":"constant"},{"location":"evolution/#QBase.σz","page":"Evolution","title":"QBase.σz","text":"σz :: Unitary{Int64}\n\nPauli-Z unitary:\n\njulia> σz\n2×2 Unitary:\n 1   0\n 0  -1\n\n\n\n\n\n","category":"constant"},{"location":"evolution/#QBase.qubit_rotation","page":"Evolution","title":"QBase.qubit_rotation","text":"qubit_rotation( θ :: Real; axis=\"x\" :: String ) :: Unitary{Complex{Float64}}\n\nReturns a unitary which performs a qubit rotation along bloch sphere. θ designates the angle of rotation and axis (\"x\", \"y\", \"z\") designates the cartesian axis about which the qubit is rotated.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#QBase.random_unitary","page":"Evolution","title":"QBase.random_unitary","text":"random_unitary( d :: Int64 ) :: Unitary{Complex{Float64}}\n\nConstructs a d x d random unitary matrix according to the Haar measure.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#Channels","page":"Evolution","title":"Channels","text":"","category":"section"},{"location":"evolution/","page":"Evolution","title":"Evolution","text":"replacer_channel\ndepolarizing_channel\nerasure_channel","category":"page"},{"location":"evolution/#QBase.replacer_channel","page":"Evolution","title":"QBase.replacer_channel","text":"replacer_channel(\n    ρ :: State,\n    σ :: State,\n    μ :: Real\n) :: State\n\nThe replacer channel replaces the quantum state ρ with quantum state σ with probability μ. The replacer channel is expressed:\n\n    mathcalR_mu(rho) = mu rho + (1-mu)sigma\n\nA DomainError is thrown if\n\nμ does not satisfy 1 ≥ μ ≥ 0\nρ and σ are not the same size\n\n\n\n\n\n","category":"function"},{"location":"evolution/#QBase.depolarizing_channel","page":"Evolution","title":"QBase.depolarizing_channel","text":"depolarizing_channel( ρ :: State, μ :: Real ) :: State\n\nThe depolarizing channel mixes uniform classical noise into a quantum state ρ. The argument μ describes the amount of noise mixed into the quantum states. For a quantum state rho, the depolarizing channel is expressed:\n\n    mathcalD_mu(rho) = mu rho + frac(1 - mu)dmathbbI_d\n\nA DomainError is thrown if μ does not satisfy 1 ≥ μ ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"evolution/#QBase.erasure_channel","page":"Evolution","title":"QBase.erasure_channel","text":"erasure_channel( ρ :: State, μ :: Real ) :: State\n\nThe erasure channel mixes a quantum state ρ with an error flag Frangle orthogonal to the Hilbert space of ρ. The argument μ describes the probability that ρ is replaced with the error flag. For a quantum state rho, the erasure channel is expressed:\n\n    mathcalE_mu(rho) = mu rho + (1 - mu) F rangle langle F\n\nNote that the erasure channel increases the dimension of the Hilbert space by 1.\n\nA DomainError is thrown if μ does not satisfy 1 ≥ μ ≥ 0.\n\n\n\n\n\n","category":"function"},{"location":"states/","page":"States","title":"States","text":"CurrentModule = QBase","category":"page"},{"location":"states/#States","page":"States","title":"States","text":"","category":"section"},{"location":"states/","page":"States","title":"States","text":"A quantum state is represented by a density operator. This matrix describes the wave function of the quantum system.","category":"page"},{"location":"states/","page":"States","title":"States","text":"is_density_matrix\nState","category":"page"},{"location":"states/#QBase.is_density_matrix","page":"States","title":"QBase.is_density_matrix","text":"is_density_matrix( ρ :: Matrix; atol=ATOL :: Float64 ) :: Bool\n\nReturns true if ρ is a valid density matrix. The following constraints must be satisfied for all density matrices:\n\nHermitian: ρ' == ρ\nPositive Semidefinite: eigmin(ρ) ≥ 0\nTrace-one: tr(ρ) == 1\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.State","page":"States","title":"QBase.State","text":"State( ρ :: Matrix{T<:Number} ) <: Operator{T}\n\nThe density matrix representation of a quantum state. The constructor, State(ρ) throws a DomainError if is_density_matrix evaluates to false.\n\n\n\n\n\n","category":"type"},{"location":"states/#State-Operations","page":"States","title":"State Operations","text":"","category":"section"},{"location":"states/","page":"States","title":"States","text":"kron(states :: Vararg{State}; atol=ATOL :: Float64)\npartial_trace(ρ::State, system::Vector{Int64}, id::Int64; atol=ATOL :: Float64)\neigvals(ρ :: State)\nis_pure\nis_mixed","category":"page"},{"location":"states/#Base.kron-Tuple{Vararg{State, N} where N}","page":"States","title":"Base.kron","text":"kron(states :: Vararg{State}; atol=ATOL :: Float64) :: State\n\nPerforms the kronecker product on the supplied states to construct a new State: rho_A otimes rho_B = rho_AB\n\nThis method extends Base.kron.\n\n\n\n\n\n","category":"method"},{"location":"states/#QBase.partial_trace-Tuple{State, Vector{Int64}, Int64}","page":"States","title":"QBase.partial_trace","text":"partial_trace(ρ::State, system::Vector{Int64}, id::Int64) :: State\n\nTakes the partialtrace of a State ρ to construct a new State: ``\\text{Tr}B[\\rho{AB}] = \\rhoA``.\n\n\n\n\n\n","category":"method"},{"location":"states/#LinearAlgebra.eigvals-Tuple{State}","page":"States","title":"LinearAlgebra.eigvals","text":"eigvals(ρ :: State) :: Vector{Float64}\n\nComputes the eigenvalues of State ρ. The eigenvalues of a density matrix are real. A DomainError is thrown if the imaginary component of any eigenvalues exceeds the absolute tolerance ρ.atol. This method extends LinearAlgebra.eigvals.\n\n\n\n\n\n","category":"method"},{"location":"states/#QBase.is_pure","page":"States","title":"QBase.is_pure","text":"is_pure(ρ :: State) :: Bool\n\nReturns true if ρ is pure, i.e. rank(ρ) == 1 within the absolute tolerance ρ.atol. This method can also be used on Matrix types.\n\nis_pure(ρ :: Matrix; atol=ATOL :: Float64) :: Bool\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.is_mixed","page":"States","title":"QBase.is_mixed","text":"is_mixed(ρ :: State) :: Bool\n\nReturns true if ρ is mixed, i.e. rank(ρ) > 1 within the absolute tolerance ρ.atol. This method also can be used on Matrix types.\n\nis_mixed(ρ :: Matrix; atol=ATOL :: Float64) :: Bool\n\n\n\n\n\n","category":"function"},{"location":"states/#State-Constructors","page":"States","title":"State Constructors","text":"","category":"section"},{"location":"states/#Singlet-States","page":"States","title":"Singlet States","text":"","category":"section"},{"location":"states/","page":"States","title":"States","text":"pure_state\nmixed_state\nbloch_qubit_state","category":"page"},{"location":"states/#QBase.pure_state","page":"States","title":"QBase.pure_state","text":"pure_state( ψ :: Ket; atol=ATOL :: Float64 ) :: State\npure_state( ψ :: Bra; atol=ATOL :: Float64 ) :: State\n\nA State is \"pure\" if it is rank-one (see is_pure). A rank-one density matrix is constructed by taking the outer-product of a Ket (or Bra) with itself, psiranglelangle psi = rho. This method alternatively accepts Vector inputs.\n\npure_state( ψ :: Vector ) :: State\npure_state( ψ :: Adjoint{T,Vector{T}} where T; atol=ATOL :: Float64 ) :: State\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.mixed_state","page":"States","title":"QBase.mixed_state","text":"mixed_state(\n    priors :: Probabilities,\n    states :: Vector{<:State};\n    atol=ATOL :: Float64\n) :: State\n\nConstructs the statistical mixture (weighted average) of quantum states. This method can also be used Vector and Matrix types which satisfy the requirements of is_probability_distribution and is_density_matrix respectively.\n\nmixed_state(\n    priors :: AbstractVector,\n    states :: Vector{<:AbstractMatrix}\n) :: State\n\nA DomainError is thrown if the provided Vectors of priors or states do not satisfy their respective requirements.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.bloch_qubit_state","page":"States","title":"QBase.bloch_qubit_state","text":"Returns the qubit density matrix for quantum state described by a coordinate on bloch sphere. See bloch_qubit_ket\n\nSpherical Coordinates:\n\nStates on the surface of bloch sphere may be described by spherical coordinates.\n\nbloch_qubit_state(θ::Real, ϕ::Real) :: State{Complex{Float64}}\n\nθ ∈ [0, π]: polar angle (w.r.t z-axis).\nϕ ∈ [0, 2π]: azimuthal angle (x-y plane)\n\nCartesian Coordinates:\n\nStates within the volume of bloch sphere may be described in cartesian coordinates.\n\nbloch_qubit_state(x::Real, y::Real, z::Real) :: State{Complex{Float64}}\n\nwhere x, y, and z are constrained to the unit sphere, 0 <= norm([x,y,z]) <= 1.\n\nA DomainError is thrown if the coordinates (x,y,z) do  not adhere to constraints.\n\n\n\n\n\n","category":"function"},{"location":"states/#Ensemble-States","page":"States","title":"Ensemble States","text":"","category":"section"},{"location":"states/","page":"States","title":"States","text":"computational_basis_states\nbell_states\ngeneralized_bell_states\nplanar_symmetric_qubit_states\ntrine_qubit_states\nmirror_symmetric_qubit_states\nsic_qubit_states\nbb84_qubit_states","category":"page"},{"location":"states/#QBase.computational_basis_states","page":"States","title":"QBase.computational_basis_states","text":"computational_basis_states( dim :: Int64 ) :: Vector{State}\n\nThe set of density matrices constructed from the computational_basis_vectors with dimension, dim.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.bell_states","page":"States","title":"QBase.bell_states","text":"bell_states() :: Vector{State{Float64}}\n\nThe Bell basis density matrices. See bell_kets for more details.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.generalized_bell_states","page":"States","title":"QBase.generalized_bell_states","text":"generalized_bell_states( dim :: Int64 ) :: Vector{State{ComplexF64}\n\nThe generalized Bell basis density matrices. See  generalized_bell_kets for more details. A DomainError is thrown if dim ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.planar_symmetric_qubit_states","page":"States","title":"QBase.planar_symmetric_qubit_states","text":"planar_symmetric_qubit_states( n :: Int64 ) :: Vector{State{Float64}}\n\nConstructs a set of pure States oriented symmetrically in the x-z-plane. See planar_symmetric_qubit_kets for details.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.trine_qubit_states","page":"States","title":"QBase.trine_qubit_states","text":"trine_qubit_states() :: Vector{State{Float64}}\n\nReturns the qubit trine states in density matrix form. See trine_qubit_kets.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.mirror_symmetric_qubit_states","page":"States","title":"QBase.mirror_symmetric_qubit_states","text":"mirror_symmetric_qubit_states( θ ::  Real ) :: Vector{State{Float64}}\n\nReturns a set of 3 mirror symmetric qubit density matrices. The first state is 0ranglelangle 0 the other two are symmetric about the  0rangle axis. See mirror_symmetric_qubit_kets.\n\nInput:\n\nθ ∈ [0,π/2]: the hilbert space angle between 0rangle and psi_23rangle.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.sic_qubit_states","page":"States","title":"QBase.sic_qubit_states","text":"sic_qubit_states :: Vector{State{Complex{Float64}}}\n\nThe quadruplet of symmetric informationally complete (SIC) qubits. The qubits are the vertices of a tetrahedron inscribed on bloch sphere. See sic_qubit_kets.\n\n\n\n\n\n","category":"function"},{"location":"states/#QBase.bb84_qubit_states","page":"States","title":"QBase.bb84_qubit_states","text":"bb84_qubit_states :: Vector{State}\n\nThe quadruplet of qubits used in the BB84 Quantum Key Distribution protocol. The states are 0ranglelangle 0, 1ranglelangle 1, +ranglelangle +, and - ranglelangle -. See bb84_qubit_kets.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = QBase","category":"page"},{"location":"#QBase.jl","page":"Home","title":"QBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A base library for quantum information.","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Alpha Version\nYour thoughts and opinions are valued and will help improve this software. To provide feedback or make feature requests, please contact brian.d.doolittle@gmail.com.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Base quantum types with a flexible tolerance for numerical error.\nConstructors for quantum state, measurement, and evolution operators.\nMethods for evolving and measuring quantum systems.\nMethods for calculating information-theoretic quantities.\nMathematics utilities that support quantum mechanics.","category":"page"},{"location":"#Base-Quantum-Types","page":"Home","title":"Base Quantum Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QBase.jl provides a general framework for representing finite quantum systems and their dynamics. Quantum mechanics is simply an application of linear algebra where particular constraints are applied to the vectors and matrices involved in the representation of quantum systems. There are three core data structures used to represent quantum systems and their behavior:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Bras and Kets:  Row and column vectors defined on a complex-valued Hilbert space.\nOperators: Matrices defined on a complex-valued Hilbert space.\nProbabilities: Real-valued vectors and matrices describing the probabilities of events.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Details regarding the definitions and constraints for each of these data structure are provided in subsequent pages of this documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ideally, the constraints on quantum objects should be met exactly, however, numerical errors are inherent to the computations involved. Therefore, each type has an absolute tolerance parameter atol which specifies how much error is allowed before the quantum object is deemed invalid. By default, the atol=1e-7 and is stored in the constant QBase.ATOL. This tolerance is sufficient for most tasks, however, it can easily be relaxed or tightened as needed.","category":"page"},{"location":"#Citing","page":"Home","title":"Citing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please see CITATION.bib for reference of this work.","category":"page"},{"location":"#Licensing","page":"Home","title":"Licensing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"QBase.jl is released under the MIT License.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Development of QBase.jl was made possible by the advisory of Dr. Eric Chitambar and general support from the Physics Department at the University of Illinois Urbana-Champaign. Funding was provided by NSF Award 1914440.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"base_types.md\", \"states.md\", \"evolution.md\", \"measurement.md\", \"informmation.md\", \"math_utilities.md\", \"examples.md\"]\nDepth = 1","category":"page"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"CurrentModule = QBase","category":"page"},{"location":"brakets/#Bras-and-Kets","page":"Bras and Kets","title":"Bras and Kets","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"In bra-ket notation, vectors on a complex-valued Hilbert space are used to represent quantum states and operations. A column vector psirangle is referred to as a ket whereas a row vector langle psi is referred to as a bra. Bras and kets are dual to each other via the adjoint operation. That is, langlepsi = psirangle^dagger and psirangle = langlepsi^dagger.","category":"page"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"Quantum systems behave probabilistically under observation, hence quantum mechanics is used to construct probability distributions which describe the behavior of quantum systems. For this reason, bras and kets must be normalized such that langlepsipsirangle = 1 holds true. Here langle  cdot  cdot rangle denotes the inner product (dot product) between bra and ket. These constraints are checked with the following method.","category":"page"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"is_braket","category":"page"},{"location":"brakets/#QBase.is_braket","page":"Bras and Kets","title":"QBase.is_braket","text":"is_braket( ψ :: Vector; atol=ATOL :: Float64) :: Bool\n\nis_braket(\n    ψ :: Adjoint{T, Vector{T}};\n    atol=ATOL :: Float64\n) where T <: Number :: Bool\n\nReturns true if vector ψ is a valid bra (or ket):\n\nψ is a real or complex-valued vector.\nψ is normalized with respect to the bra-ket inner prodcut (ψ' * ψ == 1).\n\n\n\n\n\n","category":"function"},{"location":"brakets/#Bra-Ket-Types","page":"Bras and Kets","title":"Bra-Ket Types","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"Ket\nBra","category":"page"},{"location":"brakets/#QBase.Ket","page":"Bras and Kets","title":"QBase.Ket","text":"Ket(ψ :: Vector{T}; atol=ATOL :: Float64) where T <: Number\n\nA normalized column vector on a complex-valued Hilbert space. If called with an adjoint vector ψ', the adjoint will be taken on construction.\n\nKet(ψ :: Adjoint{Vector{T}}; atol=ATOL :: Float64) where T <: Number\n\nSimilarly a Bra can be converted into a Ket via the adjoint.\n\nKet(ψ :: Bra{T}; atol=ATOL :: Float64) where T <: Number\n\nKet(ψ), throws a DomainError if ψ is not normalized.\n\n\n\n\n\n","category":"type"},{"location":"brakets/#QBase.Bra","page":"Bras and Kets","title":"QBase.Bra","text":"Bra(ψ :: Adjoint{T,Vector{T}}; atol=ATOL :: Float64) where T <: Number\n\nA row vector on a complex valued HIlbet space. Bras are dual to Kets via the adjoint If called with an Vector{<:Number} type, the adjoint will automatically be taken ψ'.\n\nBra(ψ :: Vector{<:Number}; atol=ATOL :: Float64)\n\nSimilarly a Ket can be converted into a Bra via the adjoint.\n\nBra(ψ :: Ket; atol=ATOL :: Float64)\n\nBra(ψ'), throws a DomainError if ψ' is not normalized.\n\n\n\n\n\n","category":"type"},{"location":"brakets/#Bra-Ket-Algebra","page":"Bras and Kets","title":"Bra-Ket Algebra","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"*(ket :: Ket{<:Number}, bra :: Bra{<:Number})\nadjoint(ket :: Ket{<:Number})\nkron(kets :: Vararg{Ket{<:Number}}; atol=ATOL)","category":"page"},{"location":"brakets/#Base.:*-Tuple{Ket{var\"#s1\"} where var\"#s1\"<:Number, Bra{var\"#s2\"} where var\"#s2\"<:Number}","page":"Bras and Kets","title":"Base.:*","text":"Outer product psi ranglelangle psi:\n\n*(ket :: Ket, bra :: Bra) :: Matrix\n\nInner product langle psi  psi rangle:\n\n*(bra :: Bra, ket :: Ket) :: Number\n\n\n\n\n\n","category":"method"},{"location":"brakets/#Base.adjoint-Tuple{Ket{var\"#s2\"} where var\"#s2\"<:Number}","page":"Bras and Kets","title":"Base.adjoint","text":"The adjoint is the complex conjugate transpose. This operation converts a Ket to a Bra, langle psi  = psi rangle^dagger:\n\nadjoint(ket :: Ket) :: Bra\n\nOr, convert a Bra to a Ket, psirangle = langle psi ^dagger:\n\nadjoint(bra :: Bra) :: Ket\n\n\n\n\n\n","category":"method"},{"location":"brakets/#Base.kron-Tuple{Vararg{Ket{var\"#s2\"} where var\"#s2\"<:Number, N} where N}","page":"Bras and Kets","title":"Base.kron","text":"Performs the kronecker product of a set of Kets (Bras) to produce a new Ket (Bra).\n\nkron( kets :: Vararg{Ket}; atol=ATOL ) :: Ket\nkron( bras :: Vararg{Bra}; atol=ATOL ) :: Bra\n\n\n\n\n\n","category":"method"},{"location":"brakets/#Ket-Constructors","page":"Bras and Kets","title":"Ket Constructors","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"QBase.jl provides a catalog for constructing various Kets. To construct similar Bras you must manually convert the Ket to a Bra using either adjoint(::Ket) or Bra(::Ket).","category":"page"},{"location":"brakets/#Ket-Singlets","page":"Bras and Kets","title":"Ket Singlets","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"bloch_qubit_ket","category":"page"},{"location":"brakets/#QBase.bloch_qubit_ket","page":"Bras and Kets","title":"QBase.bloch_qubit_ket","text":"bloch_qubit_ket( θ :: Real, ϕ :: Real ) :: Ket{Complex{Float64}}\n\nReturns the qubit ket for the specified spherical coordinate on the surface of bloch sphere, (r=1, θ, ϕ):\n\npsirangle = cos(theta2)0rangle + e^iphisin(theta2)1rangle\n\nIf the ket does not have a phase then a real-valued Ket is constructed as:\n\nbloch_qubit_ket( θ :: Real ) :: Ket{Float64}\n\nInputs:\n\nθ ∈ [0, 2π]: polar angle (w.r.t z-axis)\nϕ ∈ [0, 2π]: azimuthal angle (x-y plane)\n\nA DomainError is thrown if inputs θ and/or ϕ do are not within the valid range.\n\n\n\n\n\n","category":"function"},{"location":"brakets/#Ket-Ensembles","page":"Bras and Kets","title":"Ket Ensembles","text":"","category":"section"},{"location":"brakets/","page":"Bras and Kets","title":"Bras and Kets","text":"computational_basis_kets\nbell_kets\ngeneralized_bell_kets\nmirror_symmetric_qubit_kets\nplanar_symmetric_qubit_kets\ntrine_qubit_kets\nsic_qubit_kets\nbb84_qubit_kets","category":"page"},{"location":"brakets/#QBase.computational_basis_kets","page":"Bras and Kets","title":"QBase.computational_basis_kets","text":"computational_basis_kets( dim :: Int64 ) :: Vector{Ket{Int64}}\n\nThe computational basis vectors for the Hilbert space of dimension, dim.\n\nPsi =  jrangle _j=0^(d-1)\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.bell_kets","page":"Bras and Kets","title":"QBase.bell_kets","text":"bell_kets() :: Vector{Ket{Float64}}\n\nThe Bell basis kets for maximally entangled bipartite qubit systems. These kets are ordered as Phi^+rangle Phi^-rangle Psi^+rangle Psi^-rangle , where\n\nbeginmatrix\n    Phi^+rangle = frac1sqrt2(00rangle + 11rangle) \nPhi^-rangle = frac1sqrt2(00rangle - 11rangle) \n    Psi^+rangle = frac1sqrt2(01rangle + 10rangle) \n    Psi^-rangle = frac1sqrt2(01rangle - 10rangle) \nendmatrix\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.generalized_bell_kets","page":"Bras and Kets","title":"QBase.generalized_bell_kets","text":"generalized_bell_kets( dim :: Int64 ) :: Vector{Ket{Float64}}\n\nThe Bell basis for entangled bipartite quantum states each of dimension dim. Each state is constructed by\n\nPsi^p_crangle = frac1sqrtdsum_j=0^d-1 e^i2pi pjdjrangle mod(j+cd)rangle\n\nwhere pcin 0cdots (d-1) and d is dim. When iterated, c is the major index and p is the minor index.\n\nA DomainError is thrown if dim ≥ 2 is not satisfied.\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.mirror_symmetric_qubit_kets","page":"Bras and Kets","title":"QBase.mirror_symmetric_qubit_kets","text":"mirror_symmetric_qubit_kets( θ :: Real ) :: Vector{Ket{Float64}}\n\nReturns the triplet of qubit kets in the x-z plane of bloch sphere. The first ket is  0rangle and the other two are symmetric across the z-axis, pmrangle = cos(theta)0 rangle pm sin(theta)1rangle.\n\nInput:\n\nθ ∈ [0,π/2]: the hilbert space angle between 0rangle and symmetric kets.\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.planar_symmetric_qubit_kets","page":"Bras and Kets","title":"QBase.planar_symmetric_qubit_kets","text":"planar_symmetric_qubit_kets( n :: Int64 ) :: Vector{Ket{Float64}}\n\nConstructs a set of nKets oriented symmetrically in the x-z-plane. Each ket is separated by a bloch angle of 2π/n. The Kets are constructed with the form:\n\npsi_j rangle = cos(j pin)  0rangle + sin(j pin)1rangle\n\nwhere j in 0cdots (n-1).\n\nA DomainError is thrown if n < 2.\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.trine_qubit_kets","page":"Bras and Kets","title":"QBase.trine_qubit_kets","text":"trine_qubit_kets() :: Vector{Ket{Float64}}\n\nThe triplet of Kets separated by equal angles in the x-z plane of bloch sphere.\n\n    psi_1rangle = 0rangle quad\n    psi_2rangle = frac120rangle + fracsqrt321rangle quad\n    psi_3rangle = frac120rangle - fracsqrt321rangle\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.sic_qubit_kets","page":"Bras and Kets","title":"QBase.sic_qubit_kets","text":"sic_qubit_kets() :: Vector{Ket{Complex{Float64}}}\n\nThe quadruplet of symmetric informationally complete (SIC) qubits. This set of qubits correspond to the vertices of a tetrahedron inscribed on bloch sphere.\n\nbeginmatrix\n    psi_1rangle = 0rangle  quad psi_2rangle = frac1sqrt30rangle + sqrtfrac231rangle \n    psi_3rangle = frac1sqrt30rangle + sqrtfrac23 e^i 2pi31rangle  quad psi_4rangle = frac1sqrt30rangle + sqrtfrac23 e^i 4pi31rangle\nendmatrix\n\n\n\n\n\n","category":"function"},{"location":"brakets/#QBase.bb84_qubit_kets","page":"Bras and Kets","title":"QBase.bb84_qubit_kets","text":"bb84_qubit_kets :: Vector{Ket{Float64}}\n\nThe quadruplet of qubit kets used in the BB84 Quantum Key Distribution protocol. The states are 0rangle, +rangle, 1rangle, and - rangle.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/","page":"Information Theory","title":"Information Theory","text":"CurrentModule = QBase","category":"page"},{"location":"information_theory/#Information-Theory","page":"Information Theory","title":"Information Theory","text":"","category":"section"},{"location":"information_theory/#Entropy","page":"Information Theory","title":"Entropy","text":"","category":"section"},{"location":"information_theory/","page":"Information Theory","title":"Information Theory","text":"shannon_entropy\nvon_neumann_entropy\njoint_entropy\nconditional_entropy","category":"page"},{"location":"information_theory/#QBase.shannon_entropy","page":"Information Theory","title":"QBase.shannon_entropy","text":"shannon_entropy( probabilities :: AbstractVector ) :: Float64\n\nThe classical entropy of a probability distribution:\n\nS = -sum_i=1^n p_i log_2(p_i)\n\nA DomainError is thrown if input probabilities does not satisfy is_probability_distribution.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#QBase.von_neumann_entropy","page":"Information Theory","title":"QBase.von_neumann_entropy","text":"von_neumann_entropy( ρ :: AbstractMatrix ) :: Float64\n\nThe von neumann entropy of a density matrix:\n\nS(rho) = - sum_j  lambda_j log_2(lambda_j)\n\nwhere lambda_j are the eigenvalues of quantum  state rho.\n\nA DomainError is thrown if ρ does not satisfy is_density_matrix.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#QBase.joint_entropy","page":"Information Theory","title":"QBase.joint_entropy","text":"joint_entropy(priors :: AbstractVector, conditionals :: AbstractMatrix) :: Float64\n\nReturns the entropy for the union of pdf P(xy). The joint entropy is the shannon_entropy of the joint probability distribution:\n\nS(XY) = - sum_xy p(xy) log_2(p(xy))\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#QBase.conditional_entropy","page":"Information Theory","title":"QBase.conditional_entropy","text":"conditional_entropy(priors::AbstractVector, conditionals::AbstractMatrix) :: Float64\n\nReturns the conditional entropy for the system with specified priors p(x) and conditionals p(yx):\n\nS(YX) = - sum_xy p(xy)log_2left(fracp(yx)p(x)right)\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#Information","page":"Information Theory","title":"Information","text":"","category":"section"},{"location":"information_theory/","page":"Information Theory","title":"Information Theory","text":"holevo_bound\nmutual_information","category":"page"},{"location":"information_theory/#QBase.holevo_bound","page":"Information Theory","title":"QBase.holevo_bound","text":"holevo_bound(\n    priors :: AbstractVector,\n    ρ_states :: Vector{<:AbstractMatrix}\n) :: Float64\n\nThe Holevo theorem places a bound on the mutual_information I(X  Y) leq mathcalX. It places a limit on the amount information that can be decoded from a set of quantum states. For a mixed state rho = sum_i p_i rho_i the Holevo bound mathcalX is\n\nmathcalX  = S(rho) - sum_i p_i S(rho_i)\n\nwhere S(rho) is the von_neumann_entropy.\n\nA DomainError is thrown  if:\n\npriors does not satisfy is_probability_distribution.\nAny ρ ∈ ρ_states does not satisfy is_density_matrix.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#QBase.mutual_information","page":"Information Theory","title":"QBase.mutual_information","text":"mutual_information(\n    priors :: AbstractVector,\n    conditionals :: AbstractMatrix\n) :: Float64\n\nThe entropy of the overlap between p(x) and p(y). The mutual information is directly computed from the shannon_entropy and joint_entropy:\n\nI(X  Y) = S(X) + S(Y) - S(XY)\n\n\n\n\n\nmutual_information(\n    priors :: AbstractVector,\n    ρ_states :: Vector{<:AbstractMatrix},\n    Π :: AbstractVector\n) :: Float64\n\nComputes the classical mutual information for a quantum state and measurement encoding and decoding. The conditional probabilities are obtained from quantum states and measurements using measure.\n\nA DomainError is thrown if:\n\npriors does not satisfy is_probability_distribution.\nAny ρ ∈ ρ_states does not satisfy is_density_matrix.\nΠ does not satisfy is_povm.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#State-Discrimination","page":"Information Theory","title":"State Discrimination","text":"","category":"section"},{"location":"information_theory/","page":"Information Theory","title":"Information Theory","text":"success_probability\nerror_probability","category":"page"},{"location":"information_theory/#QBase.success_probability","page":"Information Theory","title":"QBase.success_probability","text":"success_probability(\n    priors::AbstractVector,\n    states::Vector{<:AbstractMatrix},\n    Π::Vector{<:AbstractMatrix}\n) :: Float64\n\nThe probability of correctly distinguishing quantum states with the specifed POVM:\n\nP_textSuccess = sum_i=1^n p_i textTrPi_i rho_i\n\nThe number of states must match the number POVMs.\n\n\n\n\n\n","category":"function"},{"location":"information_theory/#QBase.error_probability","page":"Information Theory","title":"QBase.error_probability","text":"error_probability(\n    priors::AbstractVector,\n    ρ_states::Vector{<:AbstractMatrix},\n    Π::AbstractVector{<:AbstractMatrix}\n) :: Float64\n\nThe probability of incorrectly distinguishing quantum states with the specifed POVM. This quantity is simply obtained as P_textError = 1 - P_textSuccess.\n\n\n\n\n\n","category":"function"}]
}
